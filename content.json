{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：Rotten Code 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"}],"posts":[{"title":"加密文章测试","text":"4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428ca40d00edd08503bde446612a9b43ffa557648f22736556fdb8df232a70f5b62381872db0244c43c00526e1a08cf52221edf34128af95f6689fc9f8038d2d384d80553865a152ddd5e6208a870af3b5c9bc83d20b2dbb9eed9bf4345fcbd80740d0d96973b857ce18daf962a01b68ae1d5fbd8ee95919ff5e4e59e2389903324d011f36e647c7bfde1d377a277b639b7845f1864318dedde1881f738423184c1eda461211d6767b7282687bd23a77a8725cebce8f83995baff71092164b22479 嗨，请准确无误地输入密码查看哟（密码：123456）！","link":"/posts/7e709353/"},{"title":"CountDownLatch底层实现构成，一步步分析","text":"CountDownLach 计数器 CountDownLach 的使用过程方法调用，底层源码学习。 CountDownLach： 适用于，在主线程中，开启多个子线程去统计某些不同数据的结果，然后主线程需要对这些结果进行操作的场景。 主要方法12345678// 初始化 线程阙值，AQS 的stateCountDownLach cdl = new CountDownLach(2);// 阻塞线程，进入队列候着，等待唤醒cdl.await();// 唤醒所有的线程cdl.countDown(); 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-02-18 13:05 */public class JdkCountDownLatch{ // 初始化 线程阙值，AQS 的 state = 5 private static final CountDownLatch cdl = new CountDownLatch(5); private static volatile int i; static class Task implements Runnable { @Override public void run() { // 来一个线程 state-1 // 直到为 0，cdl.await(); 后面的代码就会执行。 cdl.countDown(); ++i; System.out.println(i); } } public static void main(String[] args) { ExecutorService service = Executors.newCachedThreadPool(); // 开启5个线程 for (int j = 0; j &lt; 5; j++) { service.execute(new Task()); } service.shutdown(); try { // 线程进如队列等候 cdl.await(); System.out.println(&quot;子线程处理结果：&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } }} 底层代码验证查看 new CountDownLatch(5)12345678910111213141516171819202122232425262728293031323334353637public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); this.sync = new Sync(count);}// 内部类 Sync 继承于AQS 调用AQS的方法 设置值state的值private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } // 获取共享锁 操作 protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } // 释放共享锁，调用cutDown() 的时候 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } }} 线程数不能 &lt; 0，一个内置同步类，继承于AQS,基于AQS的state进行计数，然后进行cas操作。 cdl.await()12345678910111213141516 public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException();//tryAcquireShared AQS 的共享锁的方法，然后 CountDownLach 的 Sync 重写了 此方法，进行内部的逻辑操作 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); } tryAcquireShared(1) 1234protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } 获取 state的值，acquireSharedInterruptibly（）中if (tryAcquireShared(arg) &lt; 0){ doAcquireSharedInterruptibly(arg);} 如果state值不为0的时候，代表await()之后的代码还会继续阻塞，不会继续执行。当前调用的await的线程，就会暂时进入队列中最# 一级标题后调用USAVE.park()挂起。为0时候，说明countDown 的次数已经等于了初始化构造的时候 参数值了。此时就会从队列唤醒调用await的线程。 cdl.countDown()sync.releaseShared(1)释放锁， 12345678public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false;} tryReleaseShared() 方法，是本类中的Sysnc 中的方法，看操作源码 1234567891011121314151617181920212223242526272829303132 private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero // 一个死循环 for (;;) {// 获取state值，每个线程调一次countDown方法就会，对state-1; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } 当每个线程,调用一次countDown AQS的state值就会减1，如果在减1之前，state就为0的时候，就不会进行阻塞了，比如 new CountDownLach(5) ,但是有6条线程的时候，第六条调用countDown的时候，就会 getState==0,但是，这之前，await后面的代码已经执行了，所以 ,下面代码不会进入doReleaseShared（） 去唤醒主线程，第五天线程已经唤醒过了。 1234if (tryReleaseShared(arg)) { doReleaseShared(); return true;} ，如果这时候，第5条线程来调用countDown的时候，会cas去修改，state值，如果state-1=0时候，此时就会进入 doReleaseShared() 唤醒队列中的祝线程了。此时awite后面的代码就会执行了。 总结 流程图 CountDownLach 计数器 CountDownLach 的使用过程方法调用，底层源码学习。 CountDownLach： 适用于，在主线程中，开启多个子线程去统计某些不同数据的结果，然后主线程需要对这些结果进行操作的场景。 源码查看12345678// 初始化 线程阙值，AQS 的stateCountDownLach cdl = new CountDownLach(2);// 阻塞线程，进入队列候着，等待唤醒cdl.await();// 唤醒所有的线程cdl.countDown(); 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-02-18 13:05 */public class JdkCountDownLatch{ // 初始化 线程阙值，AQS 的 state = 5 private static final CountDownLatch cdl = new CountDownLatch(5); private static volatile int i; static class Task implements Runnable { @Override public void run() { // 来一个线程 state-1 // 直到为 0，cdl.await(); 后面的代码就会执行。 cdl.countDown(); ++i; System.out.println(i); } } public static void main(String[] args) { ExecutorService service = Executors.newCachedThreadPool(); // 开启5个线程 for (int j = 0; j &lt; 5; j++) { service.execute(new Task()); } service.shutdown(); try { // 线程进如队列等候 cdl.await(); System.out.println(&quot;子线程处理结果：&quot;+i); } catch (InterruptedException e) { e.printStackTrace(); } }} 底层代码验证查看 new CountDownLatch(5)12345678910111213141516171819202122232425262728293031323334353637public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); this.sync = new Sync(count);}// 内部类 Sync 继承于AQS 调用AQS的方法 设置值state的值private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } // 获取共享锁 操作 protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } // 释放共享锁，调用cutDown() 的时候 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } }} 线程数不能 &lt; 0，一个内置同步类，继承于AQS,基于AQS的state进行计数，然后进行cas操作。 cdl.await()12345678910111213141516 public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException();//tryAcquireShared AQS 的共享锁的方法，然后 CountDownLach 的 Sync 重写了 此方法，进行内部的逻辑操作 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); } tryAcquireShared(1) 1234protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } 获取 state的值，acquireSharedInterruptibly（）中if (tryAcquireShared(arg) &lt; 0){ doAcquireSharedInterruptibly(arg);} 如果state值不为0的时候，代表await()之后的代码还会继续阻塞，不会继续执行。当前调用的await的线程，就会暂时进入队列中最# 一级标题后调用USAVE.park()挂起。为0时候，说明countDown 的次数已经等于了初始化构造的时候 参数值了。此时就会从队列唤醒调用await的线程。 cdl.countDown()sync.releaseShared(1)释放锁， 12345678public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false;} tryReleaseShared() 方法，是本类中的Sysnc 中的方法，看操作源码 1234567891011121314151617181920212223242526272829303132 private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero // 一个死循环 for (;;) {// 获取state值，每个线程调一次countDown方法就会，对state-1; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } 当每个线程,调用一次countDown AQS的state值就会减1，如果在减1之前，state就为0的时候，就不会进行阻塞了，比如 new CountDownLach(5) ,但是有6条线程的时候，第六条调用countDown的时候，就会 getState==0,但是，这之前，await后面的代码已经执行了，所以 ,下面代码不会进入doReleaseShared（） 去唤醒主线程，第五天线程已经唤醒过了。 1234if (tryReleaseShared(arg)) { doReleaseShared(); return true;} ，如果这时候，第5条线程来调用countDown的时候，会cas去修改，state值，如果state-1=0时候，此时就会进入 doReleaseShared() 唤醒队列中的祝线程了。此时awite后面的代码就会执行了。 ::: hljs-center 关注公众号:::","link":"/posts/7ac91ac6/"},{"title":"http协议是网页开发的必备知识，是基于TCP&#x2F;IP通信协议来传输数据的。","text":"Http 协议相关知识点&emsp; http协议是网页开发的必备知识，是基于TCP/IP通信协议来传输数据的。 1、HTTP 协议的定义是什么？HTTP协议是基于 客户端/服务端 的架构模型；是一种超文本传输协议。 2、HTTP请求有那三部分组成？1.请求行\\n请求行包括了： 请求方法 url http协议版本 例如： 1234GET /write/edit/68 HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.memoryoverflow.cn....... 2.请求头部请求头包含的东西就很多可以自定义：自带一般会有 date server content-type 等字段 123456access-control-allow-credentials: trueaccess-control-allow-headers: Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers,Acceptaccess-control-allow-methods: GET, POST, PATCH, DELETE, PUT, OPTIONScontent-type: application/json;charset=UTF-8date: Sat, 28 Sep 2019 03:59:55 GMTserver: nginx/1.12.2\\nstatus: 200 3.空行空行，请求头部后面的空行是必须的；即使第四部分的请求数据为空，也必须有空行。 4.请求数据 请求数据就是：客户端于服务端交流时候，所携带的参数内容 1id=68&amp;type=intenet 一个HTTP的请求例子 1234POST /write/edit/68 http1.1\\nHost:www.memoryoverflow.cn\\nUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1;Content-Type:application/x-www-form-urlencodedConnection: Keep-Aliveid=68 HTTP响应：响应报文包括四部分：状态行，消息报头 空行 响应内容如图所示： 3、HTTP 客户端于服务端的交流过程？是基于TCP/IP通信协议来传输数据的；客户端（浏览器，默认端口是 80）—– 建立TCP连接（三次握手） —-&gt; 服务端—-断开连接（四次挥手）–&gt;响应客户端，Http(应用层)—&gt;TCP/UDP(传输层)—&gt;网络层（IP）—&gt; 链路层(网络硬件) 1.TCP的三次握手客户端于服务端建立连接之前需要进行通信测试连接 2.TCP的四次挥手当客户端的请求到服务端，服务端数据处理完成后，客户端主动断开当前连接请求第一次：客户端发送连接释放请求，FIN=1,seq=u;客户端进入FIN-WAIT-1（终止等待1）状态第二次：服务器收到连接释放信息，响应确认，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。第三次：客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。服务器将最后的数据发送完毕后，就向客户端发送连接释放信息，FIN=1，ack=u+1，； 第四此：客户端收到服务器的连接释确认消息后，必须发出确认消息，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。 **注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 4、常用的HTTP方法有哪些？ POST：常用于 传输数据到服务端 GET：一般用于 向服务去获取消息 DELETE： 用于删除数据/文件请求 PUT:常用于数据修改 HEAD:类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 OPTIONS:查询相应URI支持的HTTP方法 5、HTTP 常见状态码，有哪些？ 200 请求成功 301 资源网页被永久转移到其它URL 404 请求的路径错误，不存在 500 服务器抛出异常，服务器错误 503 服务器不存在，连接不上服务器 400 客户端请求数据格式错误 401 没有权限，未进行身份认证 405 请求方法错误 比如 后台指定的HTTP方法为 POST ,客户端发送GET请求 504 网关错误 6、HTTP 与 http 有什么区别？http:1.通信不加密，内容可能被窃听2.不验证通信方身份，可能遭到伪装3.无法验证报文完整性，可能被篡改http:是一个加密的安全协议 7、Http协议有哪些特征?1.无状态：&emsp; HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快 2.无连接&emsp;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间 3.媒体独立&emsp;这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。","link":"/posts/9c4d68f1/"},{"title":"ReentrantLock可重入锁,源码学习，分析执行原理","text":"ReentrantLock&emsp; ReentrantLock 在1.6 之前，性能比 Synchronized，好很多，因为实现同步，不需要到jvm的操作系统中处理，在java代码层面就可以处理掉，而Synchronized 是需要到操作系统处理。在1.6之后，Synchronized 进行了优化，在性上没有太多的差别。 ReentrantLock源码学习1、ReentrantLock 构造函数&emsp; 我们可以看源码/jdk.chm，知道 ReentrantLock 有两个构造函数。 代码上的锁取决于程序员的参数处理，默认使用的就是，不带参数的构造函数，也就是 非公平锁，ReentrantLock(true),使用的就是公平锁。 在这之前，先看一边源码，对它的整体过程有个大致的了解。先看看 这几个类有些什么 加锁过程 如图： 代码分析 1.1 ReentrantLock 公平锁1.11 new ReentrantLock(true) 构造static ReentrantLock lock = new ReentrantLock(true)有个构造函数，一个是有参的一个无参，根据参数 实力化一个公平锁/非公平锁。 1.12 加锁过程 new FairSync().lock()加锁过程图解 接下来看lock()方法 1234567891011final void lock() { acquire(1);} public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } tryAcquire(int acquires) 尝试加锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected final boolean tryAcquire(int acquires){ // 当前线程 final Thread current = Thread.currentThread(); /** * getState() 获取锁的状态，AQS中的一个线程共享的变量，根据此变量来判断锁的状态。 * 如果 状态为0，说明锁此时是自由状态，如果不为0，并且来取锁的线程不为当前线程， * 的话，就取锁失败 就会进入队列等待 acquireQueued(addWaiter(Node.EXCLUSIVE), arg) * 否则就是，状态++，说明自旋多了一次 */ int c = getState(); if (c == 0) { /** * hasQueuedPredecessors() * 判断队列是否已经初始化过，是否有线等待的线程 * compareAndSetState(0, acquires)： * 如果不需要进入队列等待，则进行CAS修改状态为1 取锁操作。 * * setExclusiveOwnerThread(current)： * 将获得锁的线程设置为自己 * * */ if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { // 线程重入取锁，state+1 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false;} 获得锁返回true,方法一层层返回，接着就会执行.lock()方法下的业务代码。 在并发的状况下并且存在竞争的时候，如果第一个线程，获得了锁，在业务未完成之前，锁未释放的时候，其他线程来强锁的时候，此时就会进入队列排队等候并且，队列是一个链表，因为是公平锁所以先进去的会先获得锁 hasQueuedPredecessors()方法&emsp; 12345678910public final boolean hasQueuedPredecessors() { // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());} 因为第一个进入的时候 aqs中的这个 tail 和 head 肯定是空的，所以 h != t 必定返回false。所以不加锁。 线程的并发状况，如果不存在竞争，交替执行那肯定 不会用到AQS的这个队列操 1.13 入队过程1、addWaiter(Node node)将节点包装成Node 123456789101112131415161718192021222324252627private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure /** * &lt;br&gt; * 当第一条线程入队的时候，不会走这个方法 * 当第二条线程来的时候； * 尾部节点不为空，当前线程包装的节点node.pred = pred 就是上一个线程包装的Node * compareAndSetTail(pred, node) * 将 AQS 的 tail = 当前线程包装的节点node * node.next = 当前线程包装的节点node * */ Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 第一条线程入队时候 走这个方法 enq(node); return node;} 2、enq(node)线程第一次入队的时候：走enq 123456789101112131415161718192021222324252627282930313233343536373839private Node enq(final Node node) { // 死循环 for (;;) { Node t = tail; // 第一次循环 /** * &lt;br&gt; * 第一次循环不会 尾部节点必然是空的。 * 所以初始化一个 什么都不装的Node 并且setHead * AQS的 head = new Node(); 如果node为空，在acquireQueued会报空指针。 * * 此时 AQS的 head = tail = new Node(); * * * * 因为是死循环：接着第二次遍历 * * 此时 t==null 不成立 走 else * * node.pred = AQS的 head * * compareAndSetTail(t, node) * 设置 AQS的 tail = node(当前线程包装的node) * node.next 指向自己； * */ if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } }} 3、acquireQueued 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 当线程包装成节点的时候就会调用此方法 * @param node * @param arg * @return */final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { /** * &lt;br&gt; * * 获取addWaiter包装的节点node,的山 上一个节点。 * 在 第一个线程入队的时候 head 已经初始化了，为 new Node(),第一个 * node.pred = new Node();此时 不会空，不报空指针异常； * * 第一条线程来的时候，p == head 成立，会再次走一遍 tryAcquire(arg) * 如果获得锁成功，此时修改头节点 为 node , p.next 指向为空，此时，队列没有排队的线程了。 * * a. 第一条线程来排队时候 * 假如 tryAcquire(arg) 不成立，走 shouldParkAfterFailedAcquire * * * b、第二条线程来的时候，此时获取锁的线程还没有释放，队列中已经有一条了，我是来第二个排队的 * 次条线程的node.pred 指向的就是 上一个入队的Node。 addWaiter()方法中处理的 * 此时 p == head &amp;&amp; tryAcquire(arg) 也不成立，继续走 shouldParkAfterFailedAcquire * * * */ final AbstractQueuedSynchronizer.Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); }} 4、shouldParkAfterFailedAcquire(p, node) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { /** * &lt;br&gt; * a. 假如 第一条线来排队的时候，tryAcquire(arg) 不成立；则 pred = new Node() * 此时这个 waitStatus 是初始值0； * 所以 compareAndSetWaitStatus(pred, ws, SIGNAL); * 将 pred 的waitStatus 修改为 SIGNAL = -1 */ /** * &lt;br&gt; * b. 第二条线程进来排队的时候，此时pred 就是上一个线程，就是第一个node * 上一条node进来的时候，pred.waitStatus 已经被修改为 -1了。 * 所以 ws == Node.SIGNAL 成立 返回 true,parkAndCheckInterrupt() 阻塞当前线程 * * * * */ int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } 5、入队节点 流程图 1.14 解锁过程 new FairSync().lock()unlock-&gt;sync.releas(1)-&gt;tryRelease(1) 1、release(1) 12345678910 public final boolean release(int arg) { // 如果cas 成功，唤醒队列的中中的排队线程 if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false;} 2、tryRelease(arg) 123456789101112131415161718 protected final boolean tryRelease(int releases) {// 读取state 值，减1，加锁的时候如果没有自旋 就是1，有自旋多一次也就多加一次1 int c = getState() - releases; // 判断 当前线程 是不是自己的线程 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // state为0 ， 消除持有锁的线程，修改setState的值 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } 3、unparkSuccessor(Node) 12345678910111213141516171819202122232425262728293031private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) 修改为初始值 compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; // head.next 指向的就是 队列的第一个node； // 线程 waitStatus&gt;0 线程被中断 火取消了，遍历找 最近一个 唤醒 if (s == null || s.waitStatus &gt; 0) { s = null; // 第一个被唤醒了，唤醒队列中的第一个，遍历查找 最前的 waitStatus为&lt;= 0的节点，将其唤醒，调用。 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } // 解除阻塞 if (s != null) LockSupport.unpark(s.thread);}","link":"/posts/84b802e7/"},{"title":"docker部署SprignBoot项目,注意事项","text":"Docker 笔记 Linux CentOs 下安装 Docker1、安装与启动参考地址（官网）；依照着网址即可安装。 2、Docker 常用命令 2.1 拉取镜像镜像地址：http://hub.docker.com/ 1&gt;docker pull 镜像地址 2.2 查看运行容器123&gt;docker ps&gt;docker ps -a # 查看所有容器包括不运行的 2.3 进入容器1&gt;docker exec -it 容齐id bash 2.4 删除容器123&gt;docker rm 容器id&gt;docker rm $(docker ps -aq) # 删除所有容器&gt;docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) #停用并删除容器 2.5 删除镜像1&gt;docker rmi 镜像ID 2.6 查看所有的镜像1&gt;docker images 2.7 运行镜像12&gt;docker run 镜像名称 # 最简单的 前台运行&gt;docker run -d -p 本机端口（访问端口）：容器端口 镜像名称 -d: 容器后台运行 -p:指定本机访问内部端口的映射 3、docker 安装tomcat进入网址 http://hub.docker.com/ 搜索Tomcat 复制命令： 1docker pull tomcat:jdk8 1docker images 启动 Tomcat: 1docker run -d -p 1010:8080 tomcat 启动成功 访问：http://www.memoryoverflow.cn:1010/ 要修改配置信息：进入容器内部 1docker exec -it 容器ID bash 1docker exec -it 594014aedf68 bash 进入 tomcat 内部 可以对 conf/server.xml 文件=进行修改。 4、docker 构建并且发布自己的SpringBoot项目 找到一个位置 建立一个文件夹 此处在 mkdir /usr/local/docker/demo cd /usr/local/docker/demo 建立一个文件Dockerfile touch Dockerfile 自己建立一个SpringBoot项目 写一个Controller 测试 在 pom.xml 文件中加入 配置 123&lt;properties&gt; &lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;&lt;/properties&gt; 在这中间加入： …… 12345678910111213141516171819202122&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;!-- Docker maven plugin --&gt;&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;!-- Docker maven plugin --&gt; 然后 将项目打包 比我我项目名为：demo.jar 接着 vim Dockerfile 123456789101112# 依赖于jdk 运行环境,如果还没有安装 第一次构建会自动安装FROM java:8# 作者MAINTAINER 永健&lt;memoryoverflow@163.com&gt;#一个特别指定的目录，用于存储数据VOLUME /tmp# 拷贝文件并且重命名为自己要定义的ADD demo.jar app.jar # 容器启动时运行的命令，相当于我们在命令行中输入java -jar xxxx.jar，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINTENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] ⚠️ 打好的项目jar 包要和 Dockerfile 文件在一个目录下，不然执行 build 命令的时候，会出现 not fount jar 错误。 构建镜像 1docker build -t demo . demo: 就是镜像名 自定义 注意 空格 . 构建成功 查看镜像 1docker images 运行镜像 1docker run -d -p 1595:1595 demo -d: 后台运行 -p: 端口映射 将第二个位 jar 运行的端口，映射到第一个，给外部交互访问的端口 demo: 就是build 的 镜像名字 运行成功：浏览器访问：http://www.memoryoverflow.cn:1595/hello 到此 项目部署成功。 日志查看： 1docker logs -f -t --tail -f 容器Id 5、docker JAR 项目更新5.1 docker 替换 jar 更新。 接着上面的demo操作。docker ps 查看容器id ，找我我们部署的项目，Jar 项目。 执行命令：ps exce -it 容器Id bash ls -l 查看项目内部结构，容器内部的结构目录，每个容器的结构，都是独立开的，与宿主机的结构目录不关联，在项目内是不能直接访问 宿主机结构目录的。 有个 App.jar 就是Dockerfile 里面的 add 命名 自定义的 app.jar ; 最后就是运行的这一个 app.jar 只要替换掉这个app.jar 然后重启 12docker restart 容器Id 替换命名：将宿主机的 jar 更新替换到 容器中的 jar 文件 123456docker cp 新jar的路径 容器ID:容器中的目录app.jar例如： docker cp /opt/docker/appNew.jar 容器ID:/app.jar 这样子即可替换更新 jar 文件，然后重启即可。 即可更新项目，但是这样子更新，有一个问题，如果项目是在线上的话，更新过程项目会在启动成功前无法访问。这样子会影响用户。 5.2 docker 部署 + nginx 无缝更新为了能够平滑更新，不让客户所知，可以通过nginx 处理。 之前已经打好了一个 jar 端口为 1595，现在将更新后的 jar 再继续打一个 镜像，并将该j a r 的端口改为1596，镜像名为 demo_1596。 然后就有了两个 镜像一个是 demo 一个是demo_1596 其中最新的是后者。 Nginx 配置端口拦截，之前的项目 demo 项目端口为 1595，现在将其监听的项目 转发到 ip:1596端口上，保存退出。 重启新的 jar demo_1596。 重启成功后，reload nginx 让其修改的配置信息生效。生效后，就可以 docker stop 老的容器Id了 6、docker 宿主机目录与容器目录，共享。-v 宿主机目录:容器中的目录 12docker run -d -p 8080:80 -v /home/file:/home/file app","link":"/posts/b742af1/"},{"title":"github 克隆速度慢？怎么解决，三步，速度达到 Mib&#x2F;s","text":"github 克隆dubbo源码的速度： 三步之后我们再看看速度 第一步：​ github上找到想要克隆的项目，然后先fuck 一下，对不起说错了，是fork一下。如下图所示： fork 之后，进入自己的仓库看看，像这样： 第二步：​ 到马云上，新建一个仓库，不，是码云–gitee。新建一个仓库，像这样： 一个dubbo的源码，倒入到gitee仓库10秒钟就搞定。 导入后在自己的仓库中看看，像这样： 第三步：​ 复制我们的 gitee 上的克隆地址： 执行命令： 1git clone https://gitee.com/lyj08/dubbo.git \b现在\b再看看克隆到多少了： 其实 10分钟过去了，才下载那么一点点，有时候还失败： 看看这个gitee 的速度： 这个速度，根据你的网速决定： 最后三步搞定： github fork项目。 gitee 新建仓库，从github fork的地址，导入到gitee中。 git clone gitee新建的地址。 安卓中，没有Spring?不存在的。 带你在安卓中写一个IOC、DI框架，实现Spring 的依赖注入。 并发工具CountDownLatch是如何实现阻塞的？ 接口不能被实例化，Mybatis的Mapper/Dao为什么却可以@Autowired注入？ MyBatis – Invalid bound statement (not found) 的所以然来，知其然知其所以然！","link":"/posts/e4924e28/"},{"title":"手把手教你，gitlab-ci&amp;gitlab-runner,完成自动化部署，不会不要钱，会也不要钱。","text":"前言Gitlab-ci 可以简化的项目部署操作，讲究自动化部署。只需要动动手指，在你的终端敲下 1git commit -m 'update' 即可更新仓库代码并且直接发布到线上去。 1、本机环境 Centos 7 Docker version 19.03.5 Gitlab-ce –version lastest 最新 Nginx 版本不重要 Gitlab-runner version 12.8 除此之外：还需要在部署的服务上，处理好 免密码登陆。自动化部署，自然不需要手动操。做好免密登陆，就可以将打包的dist文件夹 scp 到服务器上的nginx 指定路径，就可以直接访问了。 2、安装说明2.1 nginx 配置nginx 安装过程也略过。vim nginx.conf,进行修改。 Nginx 配置路径,转发；然后 部署脚本 要将 打包好的dist 文件夹，复制到部署的服务器上/opt/project/web/此文件夹下。 nginx -s reload 2.2 部署的服务器要做ssh 免密码登陆 登陆 要将项目发布的服务器上。 跟目录下处理 12s sh-keygen -t rsa# 输入后一直回车 默认操作即可，不加密，不改变生成文件的位置 拷贝公钥到认证文件-命令：cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys Ssh localhost 看看有没有成功 ssh-copy-id root@部署的服务器ip 此处我是部署环境，和 gitlab-runner 环境在同一个服务器上。一般情况下是两台，在开发环境下有即可配置可以。 scp 的时候 我写的是 122端口，这是我的端口，如果没有改过，默认是22 1ssh-copy-id root@thisforyou.cn 2.3 在自己的gitlab仓库上创建一个仓库，例如本机测试的。 仓库： 线下环境： 2.3 环境安装本文重点在于 gitlab-runnner的集成自动化部署，所以docker的安装，gitlab的安装，nginx 的安装过程跳过。 当你看到此文的时候，这些环境相信你也应该有了。主要是 gitlab-runner的配置问题。 2.21 基于Docker安装 gitlab-runner1、安装 目前我安装的时候是最新版本： 版本选择，移步—&gt; 1docker pull gitlab/gitlab-runner 启动命令： 我这是一个脚本 123456path=/usr/local/software/docker/gitlab-runnerdocker stop gitlab-runner &amp;&amp; docker rm gitlab-runnerdocker run -d --name gitlab-runner \\ --restart always \\ -v /usr/local/software/docker/gitlab-runner/config/gitlab-runner:/etc/gitlab-runner \\ 430012f3776d -v:将配置文件挂载到宿主机上 430012f3776d: 镜像ID 启动成功后，如果 /usr/local/software/docker/gitlab-runner/config/gitlab-runner 下没有 配置文件 config.toml 文件的话。 先停掉 docker stop gitlab-runner &amp;&amp; docker rm gitlab-runner 直接执行： docker run -d gitlab-runner 430012f3776d 然后将容器中的数据复制出来：docker cp gitlab-runner /etc/gitlab-runner :/usr/local/software/docker/gitlab-runner/config 再次 执行启动脚本。 或者等会，到注册的那一步也会生成的。 2、先到仓库拿到Token 3、注册 进入容器： 1docker exec -it gitlab-runner bash 输入 1gitlab-runner register Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): 输入你的gi tlab访问地址，上一步有说到 Please enter the gitlab-ci token for this runner: 访问token,如何获取上一步有说到 Please enter the gitlab-ci description for this runner: 输入描述，自定义 Please enter the gitlab-ci tags for this runner (comma separated): tags,在后面写脚本的时候需要用到，请先写上，我此处分两个，是在写脚本的时候，也分来个 job 来执行，所以也对应两个。非必要的，gitlab仓库上可以设置，是不是要填写，tags标签上运行。是可以限制 Please enter the executor: docker+machine, custom, docker, virtualbox, ssh, docker-ssh+machine, kubernetes, docker-ssh, parallels, shell: 这里比较重要，做java开发的，主要还是使用 ssh、shell、Docker多，至于其它那些个暂不提。 此处构建的是，vue项目，vue项目所需的是 node 环境。因为这个 gitlab-runner是基于Docker安装的，是一个独立的容器，你的服务器上的 node , git 都是无法使用的，如果此时，选择的是 shell 或者 ssh,的话，后边写执行脚本的时候 npm run build 就会报 npm not found,因为我的gitlab-runner是Docker装的，所以没有集成，其它环境。所以此时我们选择一个执行环境 为 Docker ,可以很好的管理依赖，也可以自己做一个镜像，将所需依赖放一起。 中文官网说明 Please enter the default Docker image (e.g. ruby:2.6): 选择了Docker 执行，那就需要写上 需要的docker 镜像，此处需要node环境，就直接填写：node 即可，也可以加上版本好。此处也可以通过，自己写一个Dockerfile，制作一个容器。将环境依赖都写上Dockerfile里。 4、此时是已经注册成功了，回到gitlab仓库看看 已经成功了。这里点击进去可以修改一些属性操作 5、编写脚本 编写脚本要在项目的根目录下编写； 12345678910111213141516171819202122232425262728293031323334353637383940414243# 如果是第一次看这个文件，看不明白先不要紧，先看明白它的关系先# yml格式编写## stages：通俗讲：就是将项目，从打包部署，分几个步骤，比如我这里就分两个步骤，一个 build,打包编译， deploy：部署## 如果有更多步骤就写上，比如 先 clean build test deploy ；如Java的项目： 先 mvn clean , mvn test ,mvn package# image: node # 就是所依赖的环境 在 gitrunner-cli注册的时候，已经写了此处可以省略不写stages: - build - deploy before_script: - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )' - eval $(ssh-agent -s) - ssh-add &lt;(echo &quot;$SSH_KEY&quot;) - mkdir -p ~/.ssh - '[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config' # 第一步打包， build: # build:这个名称自定义 stage: buil # 这一个stage：的值就是上面的 stages下的第一个 build tags: # tag 在注册的时候，有提到过，分两步骤，第一个是 buil,所以这里也对应上，注册的时候是自定义的名称 - buil script: # 这个就是 操作命令 或者写脚本路径 - npm install -g cnpm --registry=https://registry.npm.taobao.org # 切换cnpm 提升速度 - echo `pwd` # 我只是输出下观察写路径 - cnpm install # 安装 nodemodus - cnpm run build # 打包生成 dist 文件夹 # 缓存，因为是容器执行，每次执行的时候都会重新打包，缓存起来就不需要安装一次 cache: paths: - node_modules/ - dist/ # 第二个任务 就是 专业词语 job ,第一个是先 build ,这个跟上面的build一样名称自定义 deploy: stage: deploy # 这一个stage：的值就是上面的 stages下的第一个 deploy tags: - deploy # tag 在注册的时候，有提到过，分两步骤，第二个个是 deploy,所以这里也对应上，注册的时候是自定义的名称 script: - pwd # 也输出下路径 - mv dist vue-ci # 修改文件夹名字，对应上nginx 配置的 路径名字，不然nginx 无法正确转发 - scp -R 122 -r /dist/ root@thisforyou.cn:/opt/project # 将打包好的文件上到发布项目的服务器中的。放到nginx能访问到的文件夹下 # 我写的是 122端口，这是我的端口，如果没有改过，默认是22 ,scp 不需要 写 `—R 122` 脚本写好了，就将此文件更新到gitlab的仓库上去吧，git push之后，就会执行此脚本文件了，然后进入浏览器查看过程有没有问题。 ⚠️yaml语法检测：http://你的gitlab访问地址/账户/vue-ci/-/ci/lint 本文正确的语法 1234567891011121314151617181920212223242526272829303132stages: - build - deploybefore_script: - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )' - eval $(ssh-agent -s) - ssh-add &lt;(echo &quot;$SSH_KEY&quot;) - mkdir -p ~/.ssh - '[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config'build: stage: build tags: - buil script: - npm install -g cnpm --registry=https://registry.npm.taobao.org - echo `pwd` - cnpm install - cnpm run buildcache: paths: - node_modules/ - dist/deploy: stage: deploy tags: - deploy script: - pwd - ls -l - mv dist vue-ci - scp -P 122 -r vue-ci root@thisforyou.cn:/opt/project/web before_script: 就是在执行脚本或者命令前，先执行的操纵。比如需要预先处理，环境问题，此处是要咋dock er内配置好与服务器的免密登陆。 -ssh-add &lt;(echo “$SSH_KEY”)： $SSH_KEY，这是一个变量，需要到gitlab-ci 页面里面设置。 cat /root/.ssh/id_rsa 查看密钥，记下来,填到下面去。 查看结果： 进入第一个job build: 这图片已经不是第一次build了，前面有好几次测试，因为脚本的错 tags:buil 写错了 buid, 注册的时候，想写的是 build 却写成了 buil 。 在途中，是第已经有了nodemoduls的缓存了。 第一次build: 第二次build,纠正脚本后。 build成功了。 第一个job,成功，现在看看第二个，deploy job 看看服务器上看看 看已经有了： 先浏览器看看成功了没有： 返回上一页看，步骤结果： 现在已经部署成功； 先跑流程跑通再来看；配置文件参数详解： 值 是否必须 描述 script 必须 定义由Runner执行的shell脚本或命令 extends 非必须 定义此作业将继承的配置条目 image 非必须 需要使用的docker镜像，请查阅该文档 services 非必须 定义所需的docker服务，请查阅该文档 stage 非必须 定义一个工作场景阶段，默认是test type 非必须 stage的别名,不赞成使用 variables 非必须 在job级别上定义的变量 only 非必须 就是上面所说的，任务 jobs下的配置，only: - master 这个配置的是在仓库的哪个分支上执行的。 except 非必须 定义job所不适用的git分支 tags 非必须 定义job所适用的runner，tags为runner标签 allow_failure 非必须 允许任务失败，但是如果失败，将不会改变提交状态 when 非必须 定义了job什么时候执行，可以是on_success、on_failure、always和manual dependencies 非必须 定义了该job依赖哪一个job，如果设置该项，可以通过artifacts设置 artifacts 非必须 工件，在依赖项之间传递的东西，类似cache，但原理与cache不同 cache 非必须 定义需要被缓存的文件、文件夹列表 before_script 非必须 覆盖在作业之前执行的脚本或命令 after_script 非必须 覆盖在作业之后执行的脚本或命令 environment 非必须 定义让job完成部署的环境名称 coverage 非必须 定义job设置代码覆盖率 retry 非必须 定义job失败后的自动重试次数 不同的项目需要不同的配置 Gitlab-ci 更多的功能，等你来深究～ 中文官网说明","link":"/posts/86deff97/"},{"title":"java反射重中之重，高级编程（你会造轮子吗，造轮子，必备知识，你懂多少?）","text":"::: hljs-center 反射的使用::: java 开发中 任何的一个框架 都离不开发射机制，比如我们最熟悉的 框架Mybatis、Spring… 几乎所有封装的 框架中都离不开它，想要做架构，做工具、写一个 starter 都离不开反射机制。 所以说在开发中，反射机制运用得当可以省下很多代码。接下来个人学习的见解获取当前类的相关信息 反射机制 &emsp; 反射应该是 JVM读取相应类的 字节码文件；在类的运行状态中，通过字节码文件也就是.class文件，获取当前类的所有信息，包括 成员变量，私有、共有的方法、构造函数、以及相关的注解等。 反射的三种方式 对于任意一个类，都能够知道这个类的所有属性和方法 User.class 对于任意一个类的全路径名，都能够知道这个类的所有属性和方法 class.forName(&quot;com.baidu.User&quot;) 对于任意一个实例对象，都能够调用它的任意一个方法和属性 (new User()).getClass() 反射之构造方法1.getConstructor(Class&lt;?&gt;… parameterTypes)&emsp; 反射有三种方式，我们就采用其中一种 (new User()).getClass()通过 反射 拿到User的构造器 实例化 一个user, 一个实体类 User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class User{ private Integer id; private String name; public User() { } public User(Integer id) { this.id = id; } public User(Integer id, String name) { this.id = id; this.name = name; } public User(String name) { this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name=&quot; + name + “ '}'; } main() 方法： 1234567891011121314151617181920212223242526272829303132 public static void main(String[] args) { User user = new User(); System.out.println(&quot;new User():&quot; + user); Class&lt;? extends User&gt; aClass = user.getClass(); try { Constructor&lt;? extends User&gt; constructor = aClass.getConstructor(Integer.class, String.class); try { User newUser = constructor.newInstance(1, &quot;张三&quot;); System.out.println(&quot;反射构造到的 newUser:&quot;+newUser); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } catch (NoSuchMethodException e) { e.printStackTrace(); } }} 输出结果： 12new User():User{id=null, name='null'}反射拿到的 newUser:User{id=1, name='张三'} 2.getConstructors();获取当前类的所有public构造器这次我们使用 User.class 获取字节码文件 123456Class&lt;User&gt; aClass = User.class;Constructor&lt;?&gt;[] constructors = aClass.getConstructors();for (Constructor&lt;?&gt; constructor : constructors){ System.out.println(constructor);} 输出结果： 共有四个构造器，每个构造器的参数，都不一样，要获取指定的构造器，就使用getConstructor(Class&lt;?&gt;... parameterTypes) 12345public reflect.User(java.lang.String)public reflect.User(java.lang.Integer,java.lang.String)public reflect.User(java.lang.Integer)public reflect.User() getDeclaredConstructors() 获取类的所有构造方法 public、private 反射之获取类相关方法 方法 说明 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获取某个方法 getMethods() 获取所有的public方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获取所有的public的某个方法 getDeclaredMethods() 获取所有的public private的方法 1.getMethod(String name, Class…&lt;?&gt; parameterTypes)name:方法名称；parameterTypes:当前方法的参数类型；比如我获取 setName() 这个方法,然后调用他set一个值 1234567Class&lt;User&gt; aClass = User.class;Method method = aClass.getMethod(&quot;setName&quot;, String.class);Constructor&lt;User&gt; constructor = aClass.getConstructor();User user = constructor.newInstance();System.out.println(&quot;set值前：&quot; + user);method.invoke(user, &quot;库里&quot;);System.out.println(&quot;set值后：&quot; + user); 输出结果： 123set值前：User{id=null, name='null'}set值后：User{id=null, name='库里'} 反射之获取类属性 方法 说明 getField(String name) 获得具体的public属性对象 getFields() 获得所有public的属性对象 getDeclaredField(String name) 获取某个属性 getDeclaredFields() 获取所有的public private的方法 1.getField(String name)getField(String name) 方法 获取私有属性是抛出 找不到属性异常的。因为当前方法是 获取public 修饰的属性。 name 属性是private修饰的。 2.getDeclaredField(String name)\\ngetDeclaredField(String name) 能获取所有属性输出正确结果。 方法 说明 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 反射之获取类中相关注解1.类注解 ClassAnotation.java123456789101112131415/** * &lt;p&gt; * 一个类注解 * &lt;/p&gt; * * @author 永健 * @since 2019-09-19 21:30 */ @Documented@Retention(RetentionPolicy.RUNTIME)\\n@Target({ElementType.TYPE})public @interface ClassAnotation{ String desrc() default &quot;&quot;;} 1.getAnnotation(Class annotationClass)我们定义一个类注解，这个注解用来说明这个类是干什么的，把它放在类上面去 然后我们 通过反射获取这个注解相关信息 2.FileAnnotation.java123456@Documented@Retention(RetentionPolicy.RUNTIME)\\n@Target({ElementType.FIELD})public @interface FileAnnotation{ String desrc() default &quot;&quot;;} 模拟模拟修改加了注解的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) throws IllegalAccessException{ /** * 假如 我在做 user 插入操作的时候，id 这个主键的 生成策略 是我们自定义的id * 比如 uuid 之类的 。 我们这个时候 在需要的类 需要的字段上 加上我们的自定义注解 * * 做不同的操作； * * 这个我这个user id 不是自增的 是我自定义的主键 * * 我在 插入的时候 就不需要自己 setId(12328428342);了 通过反射 统一处理 * * 或者 创建时间 更新时间这种操作，每次更新都需要手动操作 烦死人了。 * * 这个时候我们用反射来处理 在mybatis 中 就可以使用拦截器 来修改参数值 。 * * * 此处模拟一下 id 的处理 * */ User user = new User(&quot;张三&quot;); Class&lt;? extends User&gt; aClass = user.getClass(); // 获取所有的属性 Field[] fields = aClass.getDeclaredFields(); System.out.println(&quot;给 id set 值前：&quot;+user); // 看看哪个属性 加了 我的注解 for (Field field : fields) { FileAnnotation annotation = field.getAnnotation(FileAnnotation.class); if (annotation != null) { // 这是id 属性 我需要set 值 String desrc = annotation.desrc(); String fieldName = field.getName(); System.out.println(&quot;属性：&quot; + fieldName + &quot; 加了 FileAnnotation&quot;); System.out.println(desrc); field.setAccessible(true); field.set(user,100000); System.out.println(&quot;给 id set 值后：&quot;+ user); // 继续插入操作 } }} 输出结果： 12给 id set 值前：User{id=null, name='张三'}属性：id 加了 FileAnnotation这是一个主键给 id set 值后：User{id=100000, name='张三'} 其实 Spring 框架的 @Autowired @Bean 等注解 都是基于反射机制的；依赖注入也是这个原理，不信我就简单给你试试看； @Autowired 注解怎么注入一个对像的。 3.反射实现 @Autowired 依赖注入1.建一个serviceAppleService.java 和 @Autowired 这个注解不是Spring中的那个 是我们自己的哦 2.@Autowired 3.加入到 User 属性中 4.main 方法模拟 Spring 启动 将 AppleService 实例注入到User中的 appleService 中，再调用 eat() 的方法 12345678910111213141516171819202122232425262728public static void main(String[] args) throws IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException{ User user = new User(&quot;张三&quot;); Class&lt;? extends User&gt; aClass = user.getClass(); // 获取所有的属性 Field[] fields = aClass.getDeclaredFields(); // 看看哪个属性 加了 我的注解 for (Field field : fields) { Autowired annotation = field.getAnnotation(Autowired.class); if (annotation != null) { // 获得这个属性了吧 Class&lt;? extends Field&gt; appClass = field.getClass(); // 获取属性的类型 Class&lt;?&gt; type = field.getType(); // 构造 Constructor&lt;?&gt; constructor = type.getConstructor(); // new 一个实例 Object appleService = constructor.newInstance(); // 赋值 依赖注入 field.setAccessible(true); field.set(user,appleService); // 然后我们调用 getAppleService() 来调用它的 eat()方法 user.getAppleService().eat(); } }} 输出结果： 1吃苹果 **看吧 我们的依赖注入就完成了吧，其实Spring的依赖注入就是用的反射，前面说了，优秀的框架 离不开反射机制。重点学习 反射哦，比如有比如 mybatis 的 结果集映射处理…; 没有反射就没有这么优秀的框架。关于Spring 依赖注入 我就不多说了，往后我也会根据自己的见解，写博客 mybatis 的远离分析 源码也看过了，可以看我的博客","link":"/posts/undefined/"},{"title":"MyBatis -- Invalid bound statement (not found) 的所以然来，知其然知其所以然！","text":"MyBatis – Invalid bound statement (not found) 的所以然来，知其然知其所以然！很多人刚刚开始学mybatis的时候，常常在做select、update、delete、insert的时候，会遇到类似这种， Invalid bound statement (not found)：…. 的错误。例如： 当然，我们都知到这肯定是，命名空间配置错了，或者是，dao 接口的的 方法，和 mapper文件的方法没有对应上。 这改正过来即可解决这个问题； 但是 mybatis 是怎么通过Dao/mapper接口的方法，找到对应的 xml 节点 sql 吗？ 来分析一下这其中的因为所以，抽丝剥茧。 过程看不明白直接看总结即可😂： 首先 先介绍几个类： Configuration.java mybatis 全局都围绕着它转，因为它几乎涵盖mybatis的所有初始化后要存储的信息。 Map&lt;String, MappedStatement&gt; mappedStatements： 这个 map 就是在启动项目时候，扫描xml文件对xml 节点（select、update、delete、insert）解析封装成MappedStatement对象中的。 Key:就是 命名空间+方法名，value:就是解析后一个xml 节点信息。 MappedStatement： 一个MappedStatement对应一条 xml 中的 一个节点 比如： 1234&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;BaseResultMap&quot; useCache=&quot;true&quot; timeout=&quot;&quot; resultSets=&quot;&quot; flushCache=&quot;&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_city where id =#{id}&lt;/select&gt; 在初始化过程就会解析 xml 将每一个节点信息封装成 MappedStatement 对象： 例如： id –对应的就是xml 中的 节点id 如：上面的 select 语句的 id=”findById”,其它的属性也会一一对应节点中配置的。会将入参 结果集都解析封装到其中 resultMaps… 还有sql类型….. 123456789101112131415161718192021222324// 属性 private String resource; private Configuration configuration; private String id; private Integer fetchSize; private Integer timeout; private StatementType statementType; private ResultSetType resultSetType; private SqlSource sqlSource; private Cache cache; private ParameterMap parameterMap; private List&lt;ResultMap&gt; resultMaps; private boolean flushCacheRequired; private boolean useCache; private boolean resultOrdered; private SqlCommandType sqlCommandType; private KeyGenerator keyGenerator; private String[] keyProperties; private String[] keyColumns; private boolean hasNestedResultMaps; private String databaseId; private Log statementLog; private LanguageDriver lang; private String[] resultSets; MybatisMapperProxy.java Mybatis Dao/Mapper接口的动态代理类，所有调用mapper 接口的方法，入口即在这，断点从这开始。 MapperMethod.java 在代理类MybatisMapperProxy.java 中的一个核心方法，invoke 方法最后调用的是，MapperMethod。excute()方法； 1234567// 属性// 内部类，在获取MapperMethod之前，会先 new SqlCommand 初始好，sql类型 例如：是insert还是selecprivate final SqlCommand command; // 封装了方法的参数信息 返回类型信息,// 在获取MapperMethod之前，会先 new MethodSignature,对mapper接口的方法信息进行封装 private final MethodSignature method; 知其所以然CityMapper.XML 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;generator.test.demo.core.mapper.CityMapper&quot;&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_city where id =#{id} &lt;/select&gt; &lt;!-- 通用查询映射结果 --&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;generator.test.demo.core.entity.City&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;city_name&quot; property=&quot;cityName&quot;/&gt; &lt;result column=&quot;city_code&quot; property=&quot;cityCode&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 通用查询结果列 --&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; id, city_name, city_code &lt;/sql&gt; &lt;/mapper&gt; CityMapper.java XML 解析将 sql 节点封装成 MappedStatmentXML 解析将 sql 节点封装成 MappedStatment 中，并将其 存到 Configuration 对象的的 mappedStatements s Map属性中；并且以key为 命名空间+方法Id 也就是 mapper接口的 所在全限定名+方法名； 下图是 XML 的解析流程：此处我们只看，MappedStatment 命名空间的生成 看看这个 MappedStatement 的 getId() 是什么值： debbug 看到的是 上面的 CityMapper.xml 文件的 namespace+findById (select 节点的Id组成）; 也就是等于 上面的 CityMapper.java 图片的 1+2+3+4 组成； 增删改调用过程 前面已经分析了，MappedStatement 对像的生成了，就是在初始化的过程解析 xml文件，将每个 xml的的增删改节点，封装成 MappedStatement 存到 Configuration 中的map 对象中。 并且以：key:命名空间+ sql标签Id组成。 因为是这样，所以那样,这样是那样？ 在mybatis中，在每个xml 中，每个sql的id是唯一的，mapper接口的方法也是唯一的。同一个命名空间下不用改出现两个 sql id 相同的方法。 既然存的是一个 Map对象，那拿的时候，肯定也是通过 key 来拿就是 MappedStatement Id的值； 前面讲到了代理对像 MybatisMapperProxy.java，所有mybatis 的mapper接口经过他的 invoke方法；所以断点进入这里看； findById 进来了： cachedMapperMethod(mentod)这个方法是优化了，先重缓存方法拿 MybatisMapperMethod 对象，如果拿不到就 new 一个 添加到缓存中 123private MybatisMapperMethod cachedMapperMethod(Method method) { return methodCache.computeIfAbsent(method, k -&gt; new MybatisMapperMethod(mapperInterface, method, sqlSession.getConfiguration()));} 关键步骤在 new MybatisMapperMethod(mapperInterface, method, sqlSession.getConfiguration()));中 12345public MybatisMapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) { // SqlCommand 前面有介绍 this.command = new MapperMethod.SqlCommand(config, mapperInterface, method); this.method = new MapperMethod.MethodSignature(config, mapperInterface, method); } new MapperMethod.SqlCommand 123456789101112131415161718192021222324252627public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) { // invoke 方法中拿到了执行的方法对象 从而 拿到 方法名 // 还有的就是 代理类的 class final String methodName = method.getName(); final Class&lt;?&gt; declaringClass = method.getDeclaringClass(); // 在这里获取 MappedStatement 对象 MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration); if (ms == null) { if (method.getAnnotation(Flush.class) != null) { name = null; type = SqlCommandType.FLUSH; } else { // 抛出异常 throw new BindingException(&quot;Invalid bound statement (not found): &quot; + mapperInterface.getName() + &quot;.&quot; + methodName); } } else { name = ms.getId(); type = ms.getSqlCommandType(); if (type == SqlCommandType.UNKNOWN) { throw new BindingException(&quot;Unknown execution method for: &quot; + name); } } } resolveMappedStatement() 关键方法 获取mapper接口的全限定名：mapperInterface.getName() 拼接上 方法名； 这时候就可以就可以从 configuration 中拿到了 MappedStatement对象了；返回空的时候，SqlCommad 构造函数就抛出了 异常了。 初始化的时候调用： configuration.addMappedStatement(statement); 在增删改查的时候调用： configuration.getMappedStatement(statementId); 这过程就是 Invalid bound statement (not found) 异常的 所以然来了。 总结：Invalid bound statement (not found）的产生的原因就是，xml的命名空间+sql节点的id 对应不上，Mapper接口的全限定名+当前调用的方法名； 解决办法就是： 检查 xml 的 namespace 的值是不对应上了 和 sql节点的值，或者 xml 是否被扫描到了； Invalid bound statement (not found) 的原理： 在项目启动的时候，扫描xml文件夹下的 mapper.xml文件，对 xml 的 sql 节点进行解析，将每个节点的相关信息封装到 MapperStaement对象中，然后 put 进去到 Configuration 对象中的 Map&lt;String, MappedStatement&gt; mappedStatements 属性中；ke y:命名空间+sql节点id。在调用的时候，代理对像 MybatisMapperProxy 中invoke方法 拿到当前 mapper.java 对像的class.getName()全限定名，和方法名 拼接成 statementId 去configuration.getMappedStatement(id)中获取 MappedStatement 对像。 在继续跟踪下去，就是到了 分支，通过 SqlCommad 判断 当前是增还是删 还是查还是改了……….. ::: hljs-center 打完收工关注公众号:::","link":"/posts/7c99dfb8/"},{"title":"mybatis使用存储过程","text":"1、存储过程创建&emsp; 创建存储过程使用 12345CREATE PROCEDURE name([IN 参数1 INT,OUT 参数2,OUT])BEGIN -- 业务逻辑 END; CREATE PROCEDURE: 创建存储过程的sql语法 name: 存储过程的名字 自定义 (): 括号就是参数，参数格式1、IN 代表入参 OUT 代表 输出参数，INTOUT：输入也输出2、参数1 参数name3、INT 第三个参数代表 入参 或者 出参的类型，写的是数据库的类型。4、bengin — end; 中间就是 要封装的业务逻辑。 &emsp; 例子： &emsp; 使用 navicat 软件操作 12345678910111213141516CREATE PROCEDURE pp(OUT roleId INT,OUT cityId INT,IN ciName VARCHAR(64))BEGIN -- 插入 一条数据 INSERT INTO tb_city (cityName) VALUES(ciName); -- 获取最新Id SELECT max(tb_city.id) INTO cityId FROM tb_city; INSERT INTO tb_role (name,city_id) VALUES(&quot;superman&quot;,cityId); SELECT max(tb_role.id) INTO roleId FROM tb_role; SELECT roleId; SELECT cityId;END; 2、存储过程的调用&emsp; call 存储过程的名字(参数) 以上面为例子 call pp(@roleId,@cityId,&quot;广州&quot;); 结果： 两个结果 是输出的 3、删除存储过程12DROP PROCEDURE 存储过程名字;DROP PROCEDURE IF EXISTS 过程; 4、查看存储过程状态查看状态SHOW PROCEDURE STATUS LIKE 'pp' 查看定义SHOW CREATE PROCEDURE pp 6、事务使用&emsp; 使用存储过程是为了 封装住 业务逻辑到一套sql中，减少网络的开销，提执行速度。但是一系列的表操作，必定要保证原子性，要么全部成功要么全部失败。 Mysql事务操作语句： START TRANSACTION: 开始事务，autocommit设为0，如果已经有一个事务在运行，则会触发一个隐藏的COMMIT COMMIT：提交事务，保存更改。 ROLLBACK：回滚本事务对数据库的所有更改，然后结束事务。 SAVEPOINT savepoint_name：创建一个savepoint识别符来ROLLBACK TO SAVEPOINT。 ROLLBACK TO SAVEPOINT savepoint_name：回滚到从savepoint_name开始对数据库的所有更改，这样就允许回滚事务中的一部分，保证更改的一个子集被提交 。 SET TRANSACTION：允许设置事务的隔离级别。 LOCK TABLES：允许显式的锁住一个或多个table，会隐式的关闭当前打开的事务，建议在执行LOCK TABLES语句之前显式的commit或rollback。我们一般所以一般在事务代码里不会使用LOCK TABLES 例子1:&emsp; 使用 set autocommit=0; 设置 事务不自动提交；还用上面的例子，加上事务测试： 创建： 1234567891011121314151617181920212223CREATE PROCEDURE pp(OUT roleId INT,OUT cityId INT,IN ciName VARCHAR(64)) BEGIN set autocommit=0; INSERT INTO tb_city (cityName) VALUES(&quot;广州&quot;); SELECT max(tb_city.id) INTO cityId FROM tb_city; INSERT INTO tb_role (name,city_id) VALUES(&quot;superman&quot;,cityId); SELECT max(tb_role.id) INTO roleId FROM tb_role; SELECT roleId; SELECT cityId; -- 这条语句会报错 INSERT INTO tb_city (cityName) VALUES(ciName); COMMIT;END; 对两张表进行操作，当前两张表都是空表。)) 其中city表的cityName 字段长度设为 2； 调用：call pp(@roleId,@cityId,&quot;深圳市&quot;); 看结果： 深圳市： 字段超出长度； 看看前面两张表有没有插入数据。 肯定是没有的，事务没有提交。 事务第二种方式 START TRANSACTION; 1234567891011121314151617181920212223CREATE PROCEDURE pp(OUT roleId INT,OUT cityId INT,IN ciName VARCHAR(64)) BEGIN START TRANSACTION; INSERT INTO tb_city (cityName) VALUES(&quot;广州&quot;); SELECT max(tb_city.id) INTO cityId FROM tb_city; INSERT INTO tb_role (name,city_id) VALUES(&quot;superman&quot;,cityId); SELECT max(tb_role.id) INTO roleId FROM tb_role; SELECT roleId; SELECT cityId; -- 这条语句会报错 INSERT INTO tb_city (cityName) VALUES(ciName); COMMIT;END; 事务第三种： 1234567891011121314151617181920CREATE PROCEDURE pp()BEGIN declare t_error int default 0; -- 标志执行出错 declare continue handler for sqlexception set t_error=1; -- 出错继续执行 并且设错误标志为1 START TRANSACTION; -- 开启事物 INSERT INTO tb_city (cityName) VALUES(&quot;珠海&quot;); INSERT INTO tb_role (name) VALUES(&quot;superman&quot;); INSERT INTO tb_city (cityName) VALUES(&quot;湛江23&quot;); if t_error=1 THEN ROLLBACK; -- 事物回滚 ELSE COMMIT; END IF;END; 7、变量的使用12345678910CREATE PROCEDURE bianliang()BEGIN declare count int; -- 定义变量 select count; -- 查询 结果 null set count = 10; -- 赋值 select count; -- 结果 10END; call bianliang(); 8、if-else-if根据插入id 来判断是否插入成功 1234567891011121314151617181920 CREATE PROCEDURE bianliang()BEGIN declare count int; -- 定义变量 declare lastId int; SELECT MAX(tb_city.id) INTO count from tb_city; INSERT INTO tb_city (cityName) VALUES(&quot;佛山&quot;); SELECT MAX(tb_city.id) INTO lastId from tb_city; if (lastId&gt;count) THEN SELECT '添加成功'; ELSE SELECT '操作失败'; END IF; END; 结果 9、 while ···· end while批量插入数据 1234567891011CREATE PROCEDURE whiles()BEGIN declare var int; set var =0; WHILE var&lt;5 DO INSERT INTO tb_city (cityName) VALUES(&quot;湛江&quot;); set var=var+1; END WHILE;END; 结果：","link":"/posts/baa6fbb5/"},{"title":"接口不能被实例化，Mybatis的Mapper&#x2F;Dao为什么却可以@Autowired注入？","text":"对于我们 java 来说，接口是不能被实例化的。而且接口的所有方法都是public的。 可是为什么 Mybaits 的mapper 接口，可以直接 @Autowired 注入 使用？ 接下来看看Mybatis 是如何做的。 基于SpringBoot 的 @MapperScan 注解入手，分析。 带着问题分析代码： Mybatis 的mapper接口，是怎么被扫描的？ mapper接口是如何被实例化，然后可以使用@Autowired注入？ @MapperScan1234567891011121314151617181920212223@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(MapperScannerRegistrar.class)@Repeatable(MapperScans.class)public @interface MapperScan { // 在使用MapperScan中，扫描包的路径。 // 填写的是 mapper 接口所在包名，对该value值下的所有文件进行扫描 String[] value() default {}; String[] basePackages() default {}; Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends Annotation&gt; annotationClass() default Annotation.class; Class&lt;?&gt; markerInterface() default Class.class; String sqlSessionTemplateRef() default &quot;&quot;; String sqlSessionFactoryRef() default &quot;&quot;; Class&lt;? extends MapperFactoryBean&gt; factoryBean() default MapperFactoryBean.class;} 12345678910@SpringBootApplication@MapperScan(&quot;cn.thisforyou.core.blog.mapper&quot;)public class App{ public static void main( String[] args ) { System.out.println( &quot;Hello World!&quot; ); SpringApplication.run(App.class,args); }} 在SpringBoot中使用mybatis,那它的入口就在 @MapperScan中。@MapperScan注解，是在SpringBoot的启动类中。 @MapperScan中有个 @Import 注解。 @Import 注解，可以加载某个类，放到Spring的IOC中管理在Spring中，要将Bean放到IOC容器中管理的话，有几种方式。 @Import 此种方法 @Configuration 与 @Bean 注解结合使用 @Controller @Service @Repository @Component @ComponentScan 扫描。 重写BeanFactoryPostProcessor 的postProcessBeanFactory()方法，也可以实现Bean的注入 MapperScannerRegistrar通过@Import 注解，将MapperScannerRegistrar 注入到了IOC容器中，而MapperScannerRegistrar实现这两个接口，ImportBeanDefinitionRegistrar, ResourceLoaderAware ImportBeanDefinitionRegistrar 在Spring需要配合@Impor使用，加载它的实现类，只有一个方法，是主要负责Bean 的动态注入的。 1234public interface ImportBeanDefinitionRegistrar { public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);} 这个方法可以拿到 Spring的注册对象 BeanDefinitionRegistry 这也是一个接口，提供了好6、7个方法 12345678910111213141516171819202122public interface BeanDefinitionRegistry extends AliasRegistry { // 注册 BeanDefinition void registerBeanDefinition(String var1, BeanDefinition var2) throws BeanDefinitionStoreException; // 移除 BeanDefinition void removeBeanDefinition(String var1) throws NoSuchBeanDefinitionException; // 根据name 获取一个 BeanDefinition BeanDefinition getBeanDefinition(String var1) throws NoSuchBeanDefinitionException; // 判断 是否存在 boolean containsBeanDefinition(String var1); // BeanDefinition 的适量 String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); // 是否使用中 boolean isBeanNameInUse(String var1); } BeanDefinition:是Spring对Bean解析为，Spring内部的 BeanDefinition 结构，是对类的数据包装，类全限定名，是否是单例的，是否是懒加载的，注入方式是什么… registerBeanDefinitions 注册方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, org.springframework.beans.factory.support.BeanDefinitionRegistry registry) { // 拿到注解，目的是拿到注解里的属性值，拿到值后进行扫描，并且对结果进行一个转换 AnnotationAttributes AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) { registerBeanDefinitions(mapperScanAttrs, registry); } } /** * 对 MapperScan 的属性值进行一个解析处理 * @param annoAttrs * @param registry */ void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) { /** * * 🌟 * 这是Mybatis的一个扫描器 * 也是 继承了 Spring的扫描器 ClassPathBeanDefinitionScanner */ ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader); // ........ /** * 读取包mapper包下的路径 和 要扫描的一组 mapper.class */ List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); // 🌟这是自定义扫描规则，与Spring的默认机制不同 scanner.registerFilters(); // 🌟调用扫描器 对包路径进行扫描 scanner.doScan(StringUtils.toStringArray(basePackages)); } 扫描器 ClassPathMapperScannerclassPathMapperScanner 是mybatis的一个类，继承了 ClassPathBeanDefinitionScanner，重写了doScan方法；然后也调用了 它的的扫描方法。并且定义了扫描规则，还有一些Bean的过滤，比如在一个包下，不单单有 mapper 接口的类，我们的@MapperScan主要处理的是 mapper 接口，所以将其排除: 排除掉非接口的类 1234@Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent(); } 扫描器 ClassPathMapperScanner 的doScan方法重写了父类的doScan方法，并且也调用了它的方法，通过父类的扫描结果，就将 该包下的所有 Mapper接口，解析成了 BeanDefinitionHolder，放到了 set集合中。 12345678910111213@Overridepublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) { LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in '&quot; + Arrays.toString(basePackages) + &quot;' package. Please check your configuration.&quot;); } else { // 对扫描结果进行处理，如果不处理的话，这个接口就当作了 // 一个普通的Bean注入IOC了，在引入调用，就会出现错误了。 processBeanDefinitions(beanDefinitions); } return beanDefinitions;} BeanDefinitionHolder：是BeanDefinition的持有者，包含了Be na的 名字，和Bean的别名，也包含了BeanDefinition。 processBeanDefinitions 处理BeanDefinition的BeanClass12345678910111213141516171819private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) { GenericBeanDefinition definition; // 循环遍历，一个个修改 for (BeanDefinitionHolder holder : beanDefinitions) { definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // 关键步骤： 这将 GenericBeanDefinition 的BeanClass 修改成了mapperFactoryBeanClass； // 扫描结果 这个beanClass 就是 mapper.class definition.setBeanClass(this.mapperFactoryBeanClass); definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig); // ......... } } } 我们知道Spring 中有两种Bean,一种是 普通的Bean,另一种就是 FactoryBean，如果是FactoryBean在实例化的时候，就会调用它的 getObject方法获取对象。 FactoryBean 是一个接口：mybatis的 MapperFactoryBean 实现了它； 123456789101112131415public interface FactoryBean&lt;T&gt; { // 获取对像 @Nullable T getObject() throws Exception; // 类型 @Nullable Class&lt;?&gt; getObjectType(); // 默认是单例Bean default boolean isSingleton() { return true; }} MapperFactoryBean： MapperFactoryBean 有两个属性，其中一个 1private Class&lt;T&gt; mapperInterface; 这个就是mapper接口的class,看它重写的getObject()方法； 1234@Overridepublic T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface);} 是由它的SqlSession的具体类去调用 全局的配置文件 Configuration 对象中的一个MapperRegister对象的一个getMapper方法，然后根据class从 MapperRegister 中的属性Map -&gt; knownMappers 拿到 MapperProxyFactory代理工厂，通过newInstance方法代理生成对像； 123456789101112131415161718public class MapperProxyFactory&lt;T&gt; { private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;&gt;(); // ........ // -------- @SuppressWarnings(&quot;unchecked&quot;) protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) { return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy); } public T newInstance(SqlSession sqlSession) { final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); }} 这就完成了一个对 mapper接口的处理。 在myBatis的启动过程中，会将扫描的mapper信息进行封装，所有的信息都会在 Configuration 中； 比如：一个 mapper 接口 1234package cn.thisforyou.blog.core.mapper;public interface PayMapper{ pay(String outNo)} 对接口进行解析，拿到 Class: PayMapper.class 然后 调用 MapperRegistry的 addMapper方法 包装成一个代理对像 MapperProxyFactory 放到map中，就是 key-&gt; PayMapper.class,vaue:new MapperProxyFactory(class)； 在注入的时候，就会getObect()方法，最后就调用了MapperProxyFactory.newInstance生成代理对像。 MapperRegistry 在 Configuration对象中； 最后：mapper的@Autowired 注入的其实就是 MapperFactoryBean 通过它的getObject方法，代理生成接口对象。 总结： Mybatis 的mapper接口，是怎么被扫描的？ Mybatis 通过注解@MapperScan 下的@Import注解加载，MapperScannerRegistrar类，此类继承了ImportBeanDefinitionRegistrar类,对bean的注册处理，在注册之前 会拿到 @MapperScan 的 参数值，mapper 包路径，然后调用new ClassPathMapperScanner(registry) 类去扫描，ClassPathMapperScanner extends ClassPathBeanDefinitionScanner,重写doScan方法，定义扫描规则，对扫描结果进行更改 BeanDefinition 的beanClass 进行替换成 MapperFactoryBeanClass; mapper接口是如何被实例化，然后可以使用@Autowired注入？ mapper接口没有被实例化，是通过 FactoryBean 的方式注入到 IOC 中，通过调用getObject方法生成代理对像 @Autowired的；","link":"/posts/92011cd1/"},{"title":"mysql主从同步（一主一从搭建）","text":"主服务器|角色|主机|版本||-|-|-||主服务器|centos 7 106.14.226.138|5.7.11||从服务器（docker安装的mysql）|centos 7 thisforyou.cn| 5.7.28| 1、主服务器:配置文件修改：编辑主数据苦的配置文件my.cnf vim /etc/my.cnf 1234567891011[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataport=3306# 在原有基础上增加server_id=1log_bin=/usr/local/mysql/mysql-binlog_bin_index=/usr/local/mysql/mysql-bin-indexbinlog_format=mixed 参数解释 server-id：用来标识一个唯一的实例 log_bin：二进制日志文件的路径，mysql用户对该路径必须具有读写权限. log_bin_index：二进制文件的索引路径，mysql用户对该路径必须具有读写权限. binlog_format：表示二进制日志内容的记录方式，有三种方式： a、row:基于行记录的方式，MySQL会将真实发生变化的行记录进日志，所以如果有update更新全表的操作，二进制日志文件会变得非常大。通常用于SQL语句复杂但是影响的行比较少的场景 b、statement:基于语句的方式，MySQL会将导致数据发生变化的SQL语句记录到日志文件中，适用于一条语句影响很多行的场景，但是注意当在主库上使用到了UUID，SYSDATE，FOUND_ROWS函数时，使用statement方式的复制会出现主从不一致的情况； c、mixed:混合记录模式，MySQL会自动进行判断具体是使用row格式还是statement格式，通常情况下都使用mixed，由MySQL来进行判断 log_bin、log_bin_index 所在路径授读写权限 chown 777 /usr/local/mysql/ 重启数据库，配置文件生效。/etc/init.d/mysql restart 登陆数据库 查看 binlog的二进制日志文件及位置点show master status \\G 记下来File:这个文件名称需要在从服务器上用到position: 也需要 2、将主数据库上的库，同步一份到从数据库上。 3、从服务器:修改上的mysql配置文件。mysql已经安装，配置文件一挂载到宿主机目录中。 修改vim mysql.conf.d/mysqld.cnf 12345678910111213141516[mysqld]port = 3307pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysqlmax_connections=200character-set-server=utf8max_allowed_packet=1024Mlog-error = /var/log/mysql/error.logprevent assorted security riskssymbolic-links=0# 新增server-id=2relay_log=/var/lib/mysql/mysql-replay-binrelay_log_index=/var/lib/mysql/mysql-replay-bin-index relay_log、relay_log_index: 路径是容器中的目录 relay_log： 就是从服务器上的binlog二进制文件,内容来自于，主服务器上的bin_log 内容。 配置好后重启mysql docker restart mysql/容器id 进入mysql容器docker exec -it mysql/容器id bash 可以看看 /var/lib/mysql/ 是不是多了 mysql-replay-bin.0000*;系列文件 登陆mysql，并开启主从服务mysql -uroot -p # 登陆 123456789101112131415161718&gt;CHANGE MASTER TO master_host='106.14.226.138',master_port=3306,master_user='root',master_password='123',master_log_file='mysql-bin.000004',master_log_pos =1590; # master_host: 主数据库的主机# master_user: 主数据的登陆密码（我使用的是root账户）# master_password: 密码# master_log_file: binlog二进制文件，前面在主数据看上看到的。`show master status \\G` 可看# master_log_pos: 二进制文件的位置点 `show master status \\G` 可看。# 敲下回车# 开启slave&gt; start slave;&gt; SHOW SLAVE STATUS \\G 如下图： ⚠️：Slave_IO_Running为Yes表示主从同步成功，如果为Connecting…，等待一会再看看，如果为No，表示同步失败；⚠️：失败的原因有肯能是，账号密码不对，主数据看的端口，没有外放，不允许其他ip登陆，或者账号没有权限… 此时，可以去主数据库录取一条数据测试看看是否成功！ 参考：https://segmentfault.com/a/1190000015282191","link":"/posts/c357a4cf/"},{"title":"使用Docker 快速安装 NextCloud 个人私有云盘 并且连接 Mysql 数据库，网速超快","text":"1、当然是先安装docker，此处docker环境安装不讲解​ 参考：centos 官网安装教程 2、mysql安装 安装参考：dockerHub 教程 1docker pull mysql # 拉取镜像 1docker images # 查看名称/镜像id 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d 镜像id 运行mysql 并且设置访问端口：3306，容器名称：mysql ,管理员密码：123456 配置一个账户和权限给 nextcloud 网盘使用/ 也可以不创建用户，使用root,创建个数据裤即可，为了安全起见，还是单独分配权限的好。 1docker exec -it 容器名称/容器id bash 登陆mysql 1mysql -uroot -p 接着输入管理员密码：123456 回车 创建一个数据库 1CREATE DATABASE nextcloud; 创建一个用户 1CREATE USER 'nextcloud'@'%' IDENTIFIED BY '123456'; 创建一个用户 名称为：nextcloud；‘%’：代表不限ip登陆，远程登陆; 密码为：123456。 授权 1GRANT ALL ON nextcloud.* TO nextcloud@'%' IDENTIFIED BY '123456'; 给这个用户 nextcloud 授予 这个数据库 nextcloud.* 所有的权限，远程登陆，密码为 123456； 2、NextCloud 官网 nextcloud官网 进入官网先看教程： 第一步下载镜像： 1docker pull rootlogin/nextcloud 创建一个目录将镜像的数据挂载到宿主机中 在服务器上，自己找一个目录，比如我的，/usr/local/software/docker/ 1mkdir -p /usr/local/software/docker/nextcloud/data 编写一个启动脚本 12cd /usr/local/software/docker/nextcloud/ &amp;&amp; vim start.sh 然后填写如下内容： 1234567docker stop nextcloud &amp;&amp; docker rm nextclouddocker run -d -p 9989:80 --name nextcloud \\ --privileged=true \\ --restart=always \\ --link mysql:next_cloud_db \\ # 这一行前面的 `mysql` 是 mysql 容器的名称，冒号后的 自定义的 - v /usr/local/software/docker/nextcloud/data:/data \\ # 数据挂载到宿主机中 rootlogin/nextcloud 将80端口映射为外部访问端口 9989： 端口自定义； 如果服务器防火墙没有关，开放端口，不然无法访问： 1firewall-cmd --zone=public --add-port=9989/tcp --permanent &amp;&amp; firewall-cmd --reload &amp;&amp; firewall-cmd --zone=public --list-ports 开放端口，并且reload 防火墙使其生效，查看已开放端口。 启动nextcloud 1cd /usr/local/software/docker/nextcloud/ &amp;&amp; sh start.sh 1docker ps # 检测启动是否成功 浏览器访问一下：http://服务器ip:9989 进入页面后，需要填写账户新用户账户密码：还有数据库 按图片填写即可，填写完成点击 安装完成，等待个1～2时间，成功之后，就会直接进入主页面； 此处，在用户授权的时候，最好直接填写 All 不要一个个写，容易漏掉权限，以免带来，创建数据库的的时候，报没有权限的错误。 大功告成。 看看mysql数据裤有多少东西： 看 oc_users表中会有一个管理员账户，密码是加过密的； 配置文件在：/usr/local/software/docker/nextcloud/data 中，需要修改在那里改即可； ::: hljs-center 关注公众号每天为你分享 更多内容 :::","link":"/posts/f01f8482/"},{"title":"反射实战，基于注解的形式，带你实现类似jpa的正向生成数据库表的starter","text":"::: hljs-left 反射-实战::: ==脱离实战的讲解 都是 流氓，我们即将进行反射的实战== 我们将实现一个 根据 实体 bean 加上我们的自定义注解 正向生成向库里 生成对应的表的一个 starter (SpringBoot ) 我们的项目得先引入依赖 mysql 驱动: 123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1、建立好我们的项目（SpringBoot） demo-test 是测试项目\\nforward-generation-starter 就是一个自己造的一个starter,打了一个jar 可以自行引入 2、自定义注解说明 @EnableAutoForwardGeneration 是否开启主动生成表操作 放在App启动类里面 OnOff() true:开启，false:不开启 1234567891011121314151617/** * &lt;br&gt; * 开启正向生成操作 * @author 永健 * @since 2019/5/7 14:21 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented\\n@Import(RegisterScaner.class) public @interface EnableAutoForwardGeneration { // 指定实体类所在的包 String entityPackages(); // 是否开启表自动生成 boolean OnOff() default true; } 2.@LColumn 列属性注解 12345678910111213141516171819202122232425262728293031323334353637/** * &lt;br&gt; * 列注解 * @author 永健 * @since 2019/5/7 14:37 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @Documented public @interface LColumn { /** * &lt;br&gt; * 列长度 String 类型的默认为 */ int width() default 0; /** * &lt;br&gt; * 指定数据库类型 */ ColumnType type() default ColumnType.FIELDTYPE; /** * &lt;br&gt; * 列是否默认为空 */ boolean isNull() default true; /** * &lt;br&gt; * 是否有默认值 */ String defaultValue() default &quot;&quot;; /** * &lt;br&gt; * 注释 */ String comment() default &quot;&quot;; } 3.@LIncrement 1234567891011121314/** * &lt;br&gt; * 是否自增 * @author 永健 * @since 2019/5/7 15:01 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@Documentedpublic @interface LIncrement{ IdType type() default IdType.NONE; } 4.@LNotTableField 排除非表中字段 123456789101112/** * &lt;br&gt; * 排除非表中字段 * @author 永健 * @since 2019/5/7 15:09 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @Documented\\npublic @interface LNotTableField { } 5.LTable 实体注解 指定表名 12345678910111213/** * &lt;br&gt; * 实体注解 指定表名否则转下划线 * @author 永健 * @since 2019/5/7 15:23 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented\\npublic @interface LTable { String name() default &quot;&quot;; } 6.@LTableId 主键注解 123456789101112/** * &lt;br&gt; * 主键注解 * @author 永健 * @since 2019/5/7 14:36 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @Documented public @interface LTableId\\n{ IdType type() default IdType.NONE; } 3、注解使用例子实体上的注解 123456789101112131415161718192021/** * &lt;br&gt; * * @author 永健 * @since 2019/5/7 17:31 */ @LTable(name = &quot;tb_user&quot;) public class User extends BaseEntity { @LTableId(type = IdType.AUTO) @LColumn(width = 11,type = ColumnType.INT,isNull = false,comment = &quot;主键&quot;) private Integer id; @LColumn(width = 64,isNull = true,comment = &quot;姓名&quot;,type = ColumnType.VARCHAR) private String name; @LColumn(width = 0,isNull = true,comment = &quot;出生日期&quot;) private Date birthDay; @LNotTableField private Company company; // get set 省略 } App 启动类加上注解 123456789@SpringBootApplication@EnableAutoForwardGeneration(entityPackages=&quot;com.example.demo.entity&quot;,OnOff = true)public class DemoApplication{ public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); }} application.yml 配置 12345678spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 username: root password: tiger #update 在原有的基础上更新,create：删除原来的表 根据实体信息重新建 ddl-auto: create 4、思路&emsp;其实我是学 mybatis的初始化过程的，之前有看过mybatis 源码，mybatis 也是利用Spring的扫描接口 去扫描的 mappeer.java 文件；mybatis mappe接口扫描 &emsp;使用SpringBoot 自定义一个starter,利用Spring的ClassPathBeanDefinitionScanner.java 的 doScan扫描接口，自定义扫描规则，也就是加了@LTable 注解的实体； &emsp;在starter 中的LyjAutoConfigure 实现于 InitializingBean.java 中的afterPropertiesSet 方法，在初始化bean的时候，此方法会被执行，所以这个时候我们就可以通过ConfigurableListableBeanFactory.java 中的方法 getBeansWithAnnotation(Class&lt;? extends Annotation&gt; var1) 拿到加了我们自定义注解的bean了。 12345678910111213141516171819202122232425262728@Overridepublic void afterPropertiesSet(){ // 获取自定义类注解的类 List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; map = beanFactory.getBeansWithAnnotation(LTable.class); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { classes.add(entry.getValue().getClass()); } if (classes.size()&lt;=0){ return; } ConfigureEntityTable configureEntity = new ConfigureEntityTable(); configureEntity.setProperties(this.mySqlProperties); // 解析实体 EntityParserHandler parserHandler = new EntityParserHandler(configureEntity); parserHandler.parser(classes); // 读取数据库中的表信息 TableParserHandler tableParserHandler = new TableParserHandler(configureEntity,ddlExecutor); tableParserHandler.parser(); DataBaseServiceHandler serviceHandler = new DataBaseServiceHandler(this.ddlExecutor,configureEntity); serviceHandler.excute(); logger.info(&quot;表已更新--------&gt;&quot;);} 拿到了我们的bean的信息，这会就可以通过反射，去读取类的相关信息了，比如 类上的注解啊，属性注解啊，等。这会就可以通过这个信息，属性名，转驼峰，和加上注解的一些配置值，就可以生成 我们的DDl语句了，接下来就是 连上数据库了 执行我们的sql语句去见表了。 ⚠️ 只是一个demo ，对反射的实践操作项目源码 github 源码","link":"/posts/740692cb/"},{"title":"如何将私有jar,上传到自己的nexus私服里面去？","text":"建立一个Starter例如我的一个 类似 jpa 那样的正向工具生成starter 主要配置 pom.xml在pom文件中加入 与 dependencies 标签同级 12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://thisforyou.cn:28081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://thisforyou.cn:28081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; ⚠️1.id标签：随便起，但是maven仓库中的servers节点需要与这个一至2.url：就是你的仓库地址：http://thisforyou.cn:28081/repository/maven-releases如下图所示：两个url:一个是版本带-SNAPSHOT 的一个是不带的 maven-releases：如果你的starter不version不带SNAPSHOT，就会上传到这个仓库中，代表的是正式稳定发布版本。maven-snapshots：带SNAPSHOT，就是快照版本，开发中的。 上面这两个仓库是要对应 nexus上的不然打包上传的时候，会报错 找不到对应的仓库的。 pom文件配置好后，就直接clean 然后 deploy; 查看仓库是否已经上传了： 点击进去看看，maven-public 会包含两个 一个 不带SNAPSHOT，一个带的，如果两个都上传了，就会有两个。所以这个时候的 maven 的 settings.xml配置 写maven-public就好了。 maven settings.xml配置servers 节点找到我们的本地开发的maven配置文件， conf/settiings.xml 打开编辑他：找到 servers 节点： 填写如下信息记住这个 *id 要与 pom.xml 那里的 id一至*username 就是你的账号*password 就是密码 配置好两个：一个快照的 一个 稳定版本的。 mirrors 节点id:随便写name:随便写url:填写nexus的maven-public地址即可 从私服拉取我们的jar包打开另外一个项目：填写好，刷新一下即可 Starter 源码","link":"/posts/7bc7c52/"},{"title":"将jar包做成系统服务-linux","text":"SpringBoot的项目部署有好几种，有docker方式，有war包通过tomcat部署方式，也有 java -jar 的部署方式。 本文 是基于 java -jar 来启动部署项目，做成系统服务，并且设置为开机自启 1、脚本编写目录：/opt/project jar包和启动停止脚本都基于这里操作， 一下的操作命令 都基于 这个命令 之后 cd /opt/project 将项目打好的jar包，上传至服务器的某个路径中，比如：/opt/project/boot-test.jar 在本目录下新建一个 启动脚本 start.sh 编写启动脚本 12345#!bin/shsource /etc/profile# 启动命令 nohup&gt;/opt/project/log java -jar /opt/project/jar/boot-test.jar 2&gt;&amp; 1 &amp; 停止脚本 stop.sh 12345#!bin/shpid=$(ps -ef | grep boot-test.jar | grep -v grep | awk '{print $2}')kill -9 $pidecho $pid 文件授权 如果脚本不授执行权限会出现 203 的错误 123chmod +x start.shchmod +x stop.shchmod +x boot-test.jar 编写服务文件 vim /etc/systemd/system/boot-test.serivce 填写内容： 123456789101112131415161718[Unit]Description=blog-serviceAfter=network.target[Service]Type=forkingExecStart=/opt/project/blog/start.shExecStop=/opt/project/stop.shPrivateTmp=true[Install] WantedBy=multi-user.target 2、特别注意 203 错误原因: start.sh 和 stop.sh 不授予执行权限。 解决：chmod +x start.sh &amp;&amp; chmod +x stop.sh 脚本头部没有写 #!bin/sh。vim 加上即可 jar包没有执行权限。 chmod +x boot-test.jar 其它错误原因： 例如执行完启动命令，后查看状态 systemctl status boot-test.service 启动命题提示成 status=0/SUCCESS 但是失败。 这种情况可能是：执行的 jar包所需要的环境没有。无法启动，jar包所需要的环境是 java环境。 解决办法： 在启动脚本 的 #!bin/sh 下面加上 环境变量 source /etc/profile 此命令前提是 Java已经在这文件中配置了环境变量；或者 export 123export JAVA_HOME=/usr/local/software/java/jdkexport PATH=$JAVA_HOME/bin:$PATH:/opt/project/Hexo/node_modules/.bin:$PATH 在/etc/systemd/system/boot-test.service中加入环境变量。更多配置 移步 System.service 配置详情说明 二者选一即可。 3、设置开机自启systemctl enable boot-test 启动：system start boot-test 查看状态：system stop boot-test","link":"/posts/180c3fe2/"},{"title":"根据ArrayList原理，实现一个自己的ArrayList 。。。。。。。。。","text":"手写◆ArrayList &emsp; 在前面一章中，分析了ArrayList的实现原理，现在根据它的思路，自己造一个ArrayList 属性12345678910 //默认初始化的数组长度 private static final int DEFAULT_CAPACITY = 10; //定义一个数组 private Object[] elementData;//空数组 private static final Object[] EMPTY_ELEMENTDATA = {}; //最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //数组实际大小 private int size; 构造12345678910111213141516171819/** * 默认构造函数 数组长度为10 **/ public MyArrayList() { this.size = 0; this.elementData = EMPTY_ELEMENTDATA; } /** * 定义一个固定长度的数组，如果数组小于0则抛异常 */ public MyArrayList(int initialCapacity) { if (initialCapacity &lt; 0) { throw new IllegalArgumentException(&quot;初始容量不能小于0 &quot; + initialCapacity); } this.elementData = new Object[initialCapacity]; } public int size() { return size; } add(T t)123456789101112131415161718192021222324252627282930/** * 添加方法 * 1.添加之前检查数组容量是否够用 * 2.如果不够用则对数组进行扩容,扩容为原来长度的1.5倍 * */ public void add(T t) { ensureCapacityInternal(size + 1); elementData[size++] = t; } /** * * 指定位置插入 *1.先检查下标是否越界 * 2.是否是否需要扩容 * 3.指定位置后边的元素统统往后移动一位 * 插入和删除效率低下 */ public void add(int index, T t) { //1.检查下标是否越界 rangeCheckForAdd(index); //2.是否扩容 ensureCapacityInternal(size + 1); //移位 for (int i = size(); i &gt; index; i--) { elementData[i] = elementData[i - 1]; } elementData[index] = t; size++; } get(int i)12345678/** * get方法 通过下标去数据 * 1.检查下标是否越界 */public T get(int index) { rangeCheckForAdd(index); return (T) elementData[index];} remove(Object o)123456789101112131415161718192021222324/** * 根据元素删除方法 * 2.删除指定位置的前边的元素统统往前移动一位 */public boolean remove(Object o) { if (o == null) { //移位 for (int i = 0; i &lt; size(); i++) { if (elementData[i] == null) { fastRemove(i); return true; } } } else { for (int i = 0; i &lt; size(); i++) { if (elementData[i].equals(o)) { fastRemove(i); return true; } } } return false;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package com.example.demo;import java.util.ArrayList;import java.util.Arrays;/** * Author: yj * * @Discription: * @Date:11:51 2018/8/16 * * 基于数组实现的： * 优缺点：查询快，增删慢 * * */public class MyArrayList&lt;T&gt; { //默认初始化的数组长度 private static final int DEFAULT_CAPACITY = 10; //定义一个数组 private Object[] elementData; //空数组 private static final Object[] EMPTY_ELEMENTDATA = {}; //最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //数组实际大小 private int size; /* * 默认构造函数 数组长度为10 * */ public MyArrayList() { this.size = 0; this.elementData = EMPTY_ELEMENTDATA; } /** * 定义一个固定长度的数组，如果数组小于0则抛异常 */ public MyArrayList(int initialCapacity) { if (initialCapacity &lt; 0) { throw new IllegalArgumentException(&quot;初始容量不能小于0 &quot; + initialCapacity); } this.elementData = new Object[initialCapacity]; } public int size() { return size; } /** * 添加方法 * 1.添加之前检查数组容量是否够用 * 2.如果不够用则对数组进行扩容,扩容为原来长度的1.5倍 * */ public void add(T t) { ensureCapacityInternal(size + 1); elementData[size++] = t; } /** * * 指定位置插入 *1.先检查下标是否越界 * 2.是否是否需要扩容 * 3.指定位置后边的元素统统往后移动一位 * 插入和删除效率低下 */ public void add(int index, T t) { //1.检查下标是否越界 rangeCheckForAdd(index); //2.是否扩容 ensureCapacityInternal(size + 1); //移位 for (int i = size(); i &gt; index; i--) { elementData[i] = elementData[i - 1]; } elementData[index] = t; size++; } /** * 根据下标 删除方法 * 1.先检查下标是否越界 * 2.删除指定位置的前边的元素统统往前移动一位 */ public T remove(int index) { rangeCheckForAdd(index); T oldIndex = (T) elementData[index]; //移位 fastRemove(index); for (int i=index;i&lt;size()-1;i++) { elementData[i]=null; if (i==size) { } elementData[i]=elementData[i+1]; } return oldIndex; } /** * 根据元素删除方法 * 2.删除指定位置的前边的元素统统往前移动一位 */ public boolean remove(Object o) { if (o == null) { //移位 for (int i = 0; i &lt; size(); i++) { if (elementData[i] == null) { fastRemove(i); return true; } } } else { for (int i = 0; i &lt; size(); i++) { if (elementData[i].equals(o)) { fastRemove(i); return true; } } } return false; } public void fastRemove(int index) { for (int i = index; i &lt; size() - 1; i++) { elementData[i] = null; elementData[i] = elementData[i + 1]; } size--; } /** * get方法 通过下标去数据 * 1.检查下标是否越界 */ public T get(int index) { rangeCheckForAdd(index); return (T) elementData[index]; } /** * 检查数组容量是否够用 */ public void ensureCapacityInternal(int minCapacity) { //数组元素个数大于初始化的数组长度时候 if (minCapacity - elementData.length &gt; 0) { //进行数组扩容 grow(minCapacity); } } /** * * 数组扩容 * */ public void grow(int minCapacity) { int oldLen = elementData.length; int newLen = oldLen + oldLen &gt;&gt; 1; //左移位 相当于除以2 //加一个元素就加长一个长度，最少保证容量和minCapacity一样 if (newLen - minCapacity &lt; 0) { newLen = minCapacity; } //如果扩充一半后仍然不够，则 newCapacity = minCapacity;minCapacity实际元素的个数。 if (newLen - MAX_ARRAY_SIZE &gt; 0) { newLen = hugeCapacity(minCapacity); //数组最大位2^32 } elementData = Arrays.copyOf(elementData, newLen); } /** * * 下标越界检查 * */ private void rangeCheckForAdd(int index) { if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(&quot;下标越界异常&quot;); } /** * * 赋值数组最大长度 * */ private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } public static void main(String[] a) { MyArrayList&lt;String&gt; stringMyArrayList = new MyArrayList&lt;&gt;(); stringMyArrayList.add(&quot;张三&quot;); stringMyArrayList.add(&quot;李四&quot;); stringMyArrayList.add(1, &quot;王五&quot;); stringMyArrayList.add(1, &quot;王麻子&quot;); stringMyArrayList.add(0, &quot;刘能&quot;); stringMyArrayList.add(5, &quot;刘能去&quot;); //stringMyArrayList.remove(3); stringMyArrayList.remove(&quot;张三&quot;);// for (int i = 0; i &lt; 15; i++) {// stringMyArrayList.add(String.valueOf(i));// } for (int i = 0; i &lt; stringMyArrayList.size(); i++) { System.out.println(stringMyArrayList.get(i)); } }}","link":"/posts/e51c6570/"},{"title":"用自己的物理服务器 搭建私服，拥有自己的maven服务","text":"前言 最近买了个物理服务器，目的就是为了折腾，学习；因为想要达到玩学习的目的，买里云的太贵了。学生机，配置太低。根本无法折腾。索性淘宝搞一个 戴尔的玩玩。 将服务器在家里，即使出门在外，也一样可以像阿里云的服务器一样通过域名访问 ssh 等。但是得有一个公网ip，家里的宽带是电信的，一个10000客服，说要个公网ip,用于家里的监控。就直接将宽带设置成了公网的。 不过打了好几个客服，这些客服感觉不太专业，有些客服说 这个公网ip是固定不变的，有的说这个公网ip是动态的。后者是对的；拿了公网ip一顿折腾，大年初一 都骚扰 电信的维修师傅。最终还是搞好了。然后阿里云买个域名，写个脚本，动态获取公网ip ddns绑定 就可以通过域名直接访问了。 主题开始：因为平时个人开发的一些demo或者个人的项目的时候总有很多工具类要用到，几乎很多个人项目都要用到，所有就想把它做成一个jar包 直接私服里面一丢，在项目里直接引用就好，不需要一个个复制来去。 用阿里云的学生机也试过，跑不起来。就是很多都不能玩所以才这样子处理。 拉取镜像：Docker Hub 搜索 sonatype/nexus3 拉取镜像 docker pull sonatype/nexus3 查看镜像id:docker images 在任意一个目录下，创建一个文件夹 用于数据挂载 mkdir /usr/local/software/docker/nexus/data 务必授权，我因为没有授权所以总是跑不起来 200或者777chown -R 200 /usr/local/software/docker/nexus/data 写一个启动脚本： 12345678docker stop nexus3 &amp;&amp; docker rm nexus3docker run -d --name nexus3 \\ -p 8081:8081 \\ -p 8082:8082 \\ -p 8083:8083 \\ -p 8084:8084 \\ --restart=always \\ -v /usr/local/software/docker/nexus/data:/nexus-data 87d9a097d22c 命令执行完后：docker ps 查看运行情况可能会运行比较久，我就是很久 5、6分钟才运行起来。 查看 上面创建 创建的data文件家看看是否有文件了，管理元密码在里面。 然后：浏览器访问：http://服务器IP:8081;即可进入界面 点右上角 的 sign in 进行登陆： 查看管理员密码 /usr/local/software/docker/nexus/data/admin.password登陆后 会询问你是否修改密码，修改后这个文件就不在了，注意⚠️。","link":"/posts/62da2a0d/"},{"title":"项目生成工具,根据数据库生成，助你效率翻倍","text":"最近，个人也接了点不足挂齿的小小私活。为了快速开发，开箱即用，每个项目不需要重新搭建。提升效率，就写了基本的项目架子，然后根据已建好的数据库，生成对应的增删改查的接口。生成即可使用。 一、生成的项目结构说明一、项目技术SpringBoot + shiro + mysql + mybatis-plus; 项目统一 restful 风格，统一异常 Json 处理化，respones 数据结构统一。 跨域问题处理。 也会过滤掉给前端的 一些 为 null 的属性，将值填充为 空字符串 “”； 也包含了日志文件输出。 下面就是工具生成的项目结构 二、项目结构项目的基本结构如上图所示。这是一块公共的代码块。 core 包： 是数据库生成的业务代码增删改； mapper 文件 在resoure 目录下。 每一个类，都有一个注释说明，在这就不一一做解释了。 二、业务代码模块每一张表，都有对应的 增 删 改 查 的接口。使用的不同请求方式。 增 删 改 查 接口 这样。 数据结构长这样： 这是查的接口数据结果，包含了分处理。 Service 接口： ServiceImpl Mapper接口： xml: 这是项目的基本结构了。 三、相关文件1、R.java 封装统一响应前端数据结构 2、统一异常枚举 3、定义自定义异常，限制错误枚举 4、全局异常捕获拦截 基本的结构代码，介绍到此。 二、项目生成工具源码结构工具源码结构 源码结构不做说明了，太多东西。 2、1 项目工具的使用 项目所需属性在类 ConfigProperties.java 中 可通过 main 方法进行项目的快速生成 也可以部署出去，通过 http 的形式，打包下载。 页面 源码地址","link":"/posts/434af8d5/"},{"title":"ConcurrentHashMap源码过程执行过程分析","text":"::: hljs-center ConcurrentHashMap 1.7 源码分析学习::: 1、常量说明 123456789101112131415161718192021222324252627282930// concurrentHashMap 默认长度static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认扩容因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认 Segment[].length 长度static final int DEFAULT_CONCURRENCY_LEVEL = 16;// concurrentHashMap 最大容量值static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 每一个 Segment 对象中的 hashTable 数组最小长度static final int MIN_SEGMENT_TABLE_CAPACITY = 2;// Segment[] 最大值static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative// 非锁定情况下调用size和contains方法的重试次数,避免由于table连续被修改导致无限重试static final int RETRIES_BEFORE_LOCK = 2;//计算segment位置的一个值final int segmentMask;//计算segment位置时,用于hash参与运算的位数final int segmentShift;//Segment[]数组final Segment&lt;K,V&gt;[] segments; 2、数据结构图 ConcurrentHashMap 底层数据结构是采用分段式存储数据，每一个Segment就是一段，都是一个非公平锁锁，继承于 ReentrantLock,是线程安全的。每一个Segment 下中，都有一个数组，当put值的时候，算出了key所在segment[]中的位置后，put 就会锁住，当前的这个segment对象，其它的segment 是不上锁的。这区别于 hashTale, hashTable 是锁整个对象，每个方法上 synchronized 锁住，所以在效率上会 大大由于 hashTable。 3、Segment 对象Segment 对象继承了ReentrantLock，对每一个Segment 对象进行分段锁，当线程执行put的时候，只锁住对应的 那个Segment 对象，对其他的Segment 的get put 互不干扰，这样子就提升了效率；做到了线程安全。 对于 HashTable 是锁住的整个HashTable,每个方法都上了锁，线程量大的时候，会消耗cpu,效率也低下。 12345678910111213141516171819202122232425static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable{ // HashEntrys数组，数组又装链表 transient volatile HashEntry&lt;K,V&gt;[] table; // 数组长度 transient int count; // 操作次数 transient int modCount; // 扩容的一个判断条件 数组长度*负载因子 默认 0.75 transient int threshold; // 负载因子 0.75 final float loadFactor; Segment(float lf, int threshold, ConcurrentHashMap.HashEntry&lt;K,V&gt;[] tab) { this.loadFactor = lf; this.threshold = threshold; this.table = tab; }} 4、构造初始化1、构造 参数介绍： int initialCapacity #concurrentHashMap 初始容量 float loadFactor # 加载扩容因子 int concurrencyLevel # segment[]成度 默认构造方法，都是使用默认参数值,其它构造 最终都是调用此构造 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public ConcurrentHashMap( int initialCapacity, float loadFactor, int concurrencyLevel) { // 参数校验 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; /** * // Find power-of-two sizes best matching arguments * * 找到两个大小的最佳匹配参数的幂，就是计算出，每个 segment 下 应该放几个 hashEntry对象，就是它的hashEntry[]长度 * */ int sshift = 0; // 通过计算获取 segment[] 数组长度的最佳值 int ssize = 1; /** * 举例子： * initialCapacity = 33，concurrencyLevel = 16； * while 循坏，ssize = 0, 第一次 就是 2，第二次 就是 4 ，第三次就是 8，第四次就是 16 * * 此时 (ssize = 16 ) &lt; concurrencyLevel = 16 跳出循环，sshift 加加了四次 sshift = 4 ; * * 从 ssize &lt;&lt;= 1 来看， segment[] 长度就是，2的幂次方； 为什么是 2的幂次方，为了减少 hash冲突； */ while (ssize &lt; concurrencyLevel) { ++sshift; ssize &lt;&lt;= 1; } // 也计算得出 了 参与 计算 key要存储的下表位置的值； this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; // 计算结果 也不能 大于 segment[] 默认的最大长度，超出则为最大值 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; /** * * 计算 每个 HashEntry 的最佳长度 * * （initialCapacity = 33）/ 计算出来的( ssize=16 ) * * 目的就是 出现分配不均 的情况 * * 假如 segment[]=16;最大容量是 33 个；如果每个 hashEntry[].length=2,那装不完 * * 33/16=2.多；就每个 hashEntry[].length+1; 保证装完 * */ int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; // 如果计算出的 c 小于 默认 最小 容量，就取 默认值，2的幂次方，最小就是2 int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] /** * &lt;br&gt; * * 初始化Segment对象 * 。loadFactor:Segment[]数组的扩容因子 * 。(int) (cap * loadFactor):hashEntry[]的扩容因子 * 。new HashEntry[cap]：初始化Segment对象下的数组 * * */ Segment&lt;K, V&gt; s0 = new Segment&lt;K, V&gt;(loadFactor, (int) (cap * loadFactor), (HashEntry&lt;K, V&gt;[]) new HashEntry[cap]); /** * * 初始化 Segment 数组 * */ Segment&lt;K, V&gt;[] ss = (Segment&lt;K, V&gt;[]) new Segment[ssize]; /** * &lt;br&gt; * * putOrderedObject（obj,offset,val） * 将obj对象的偏移量为offset的位置修改为value * * SBASE = UNSAFE.arrayBaseOffset(sc); * 读取数组第一个的偏移量，然后 putOrderedObject 负值 * */ UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } 构造函数，Segment[] 数组进行了初始化，并且计算出，每个Segment 对象最优存储个数，以及Segment[]的长度计算，根据代码的算法，Segment[]的长度是一定是2的幂次方，最小的长度 是2，hashEntry[]的长度也是2的幂次方。 5、ConcurrentHashMap.put(K k,V v) 1234567891011121314151617181920212223242526272829303132public V put(K key, V value){ Segment&lt;K, V&gt; s; // put 方法 没有做key 的非空校验，1.8的做了校验 if (value == null) throw new NullPointerException(); // 计算key 的 hash值 int hash = hash(key); // 计算 这个key 在Segment[] 数组中的哪个位置； int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; /** * &lt;br&gt; * * UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE) * 去拿这个这个下表位置的偏移量，通过此方法获取这个偏移量位置的Segment对象是否为空； * * 在构造的时候，只初始化了，下表为0的，第一个元素； * * s = null 的话，就 ensureSegment 实实例化出来 * */ if ((s = (Segment&lt;K, V&gt;) UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);} 5.1 ensureSegment(j) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private Segment&lt;K,V&gt; ensureSegment(int k) { // 读取Segment[] final Segment&lt;K,V&gt;[] ss = this.segments; // 在获取一次 key 在数组中的偏移量 long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset // 生明 即将实例化的Segment对像 Segment&lt;K,V&gt; seg; /** * &lt;br&gt; * 防止其它线程 在此线程修改前已经修改了 * * UNSAFE.getObjectVolatile(ss, u) * 从对象的指定偏移量处获取变量的引用 * 再次判断是否为空 * * */ if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { // 为空的话，就拿构造初始化的Segment对象作为原型，拿取，hashEntryp[]长度,和加载因子 // 去实例化新的Segment对像 Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype int cap = proto.table.length; float lf = proto.loadFactor; // 计算数组的 加载因子 int threshold = (int)(cap * lf); // 实例化 hashEntry数组 HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap]; /** * &lt;br&gt; * * 再次复查当前位置是否为空 * 防止其它线程 在此线程修改前已经修改了 * * 否则直接return即可 */ if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck // 实例化 Segment 对象 Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab); /** * &lt;br&gt; * * 使用循环知道cas成功为止，因为有时候会cas失败； * */ while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { // cas 修改数组中的key在的下标位置的值，原来为 null,修改值为 新对象 if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) break; } } } return seg; } 5.2 Segment.put(K key, int hash, V value, boolean onlyIfAbsent)将 key value 包装成 HashEntry 对象，假如到数组中，或者HashEntry 链表中去； Segment 继承了 ReentrantLock ，是一把锁，在此put 方法中进行 tryLock(), 获取锁，获取失败，救会scanAndLockForPut(key, hash, value),进行循环重试取锁，如果到达指定的尝试次数还没有锁的话，就会lock() 进入队列等待。 此锁是非公平锁。 put 方法： 注意点： &emsp; 1、hash冲突，key相同的情况，处理？ &emsp;&emsp; &emsp; hash 冲突，key 相同的情况下，会默认 进行，值替换，新值覆盖旧值。 &emsp; 2、key 的hash冲突，key 不相同的情况？ &emsp;&emsp;&emsp; 只是 key的 hash 冲突，的话，就会在链表的头节点加入新的包装的HashEntry对象； &emsp; 3、Segment下的HashEntry 数组装不下怎么办？ &emsp;&emsp;&emsp; 在加入之前，根据加载因子去计算，是否需要扩容，不需要扩容就直接加入，否则就会对数组进行扩容。 代码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100final V put(K key, int hash, V value, boolean onlyIfAbsent) { /** * &lt;br&gt; * * 开始上锁了 * tryLock()；是 ReentrantLock 里面的方法；是非公平锁； * tryLock()失败，就会 * * scanAndLockForPut(); * 进行重试获取锁，在不超过 RETRIES_BEFORE_LOCK = 2 次数的时候，2 是默认值 */ HashEntry&lt;K, V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { HashEntry&lt;K, V&gt;[] tab = table; // 计算HashEntry对象在 HashEntry[]数组中的位置，这个算法跟 HashTable一样的 int index = (tab.length - 1) &amp; hash; // 获取这个 数组中的，这个下标位置是的值，有可能为空，有可能存在值，存在值说明hash冲突了 HashEntry&lt;K, V&gt; first = entryAt(tab, index); // 遍历 HashEntry&lt;K,V&gt; 链表结构， for (HashEntry&lt;K, V&gt; e = first; ; ) { // e !=null 有可能是hash冲突了，存在 链表 if (e != null) { /** * &lt;br&gt; * * 继续进一步判断 key 的内存是否相等、 * 内存地址是否相等、hash 值是否相等。 * * 这个判断跟 HashTable的判断也是一样的 * * */ K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { // 此时key相等了，就判断是否新值覆盖旧值 oldValue = e.value; // 是否覆盖 if (!onlyIfAbsent) { // 覆盖 e.value = value; // 修改次数加一 ++modCount; } break; } // 如果 只是hash冲突，key的值不等，就形成了链表 e = e.next; } else { // 没有hash冲突，HashEntry 没有存在链表； if (node != null) // 新增的节点，设置为头节点 node.setNext(first); else // 创建新的HashENtry对象，并且设置为头节点 node = new HashEntry&lt;K, V&gt;(hash, key, value, first); // 数组容量加一，就是判断，新增这个key之后，这个数组的容量是否需要扩容 int c = count + 1; // 判断是否需要扩容 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else // 不需要扩容，就将数组下的这个位置，替换为新的HashEntry setEntryAt(tab, index, node); // 修改次数+1 ++modCount; count = c; oldValue = null; break; } } } finally { // 释放锁 unlock(); } return oldValue; } 5.21 scanAndLockForPut(K key, int hash, V value) tryLock()；是 ReentrantLock 里面的方法；是非公平锁； tryLock()失败，就会 scanAndLockForPut(); 进行重试获取锁，在不超过 RETRIES_BEFORE_LOCK = 2 次数的时候，2 是默认值; 重试次数大于 指定的重试值的时候，线程被挂起，进入AQS 的队列等待 1234567891011121314151617181920212223242526272829303132333435363738394041private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) { // 根据 获取当前数组下的位置，获取第一个HashEntry HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; // 初始化 重试获取锁的标志次数 int retries = -1; // negative while locating node // 尝试循环重试读锁 while (!tryLock()) { HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) { // 如过 数组的下标这个位置是空的，初始化新的HashEntry对象， // return 回去，在判断是否存在链表 if (e == null) { if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; } else if (key.equals(e.key)) retries = 0; else e = e.next; } else if (++retries &gt; MAX_SCAN_RETRIES) { // 如果 重试次数到达最大值，阻塞进入AQS的队列排队 lock(); break; } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) { // 判断 这个位置是否有被修改，修改了则重新初始化其它值 e = first = f; // re-traverse if entry changed retries = -1; } } return node; } 6、rehash(HashEntry&lt;K,V&gt; node) 扩容在新增key的时候，就会判断是否需要扩容，扩容条件就是。新增后的个数大于数组容量*加载因子(默认0.75) 并且 数组的容量在不大于最大容量的时候&emsp; (count &gt; (cap * lf) &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) 扩容过程：1、扩容后的容量是原来数的一倍，最后还是2的幂次方。2、重新计算数 HashEntry 在新的数组上的位置。 遍历老的HashEntry[] 数组，进行数据迁移，先要重新拿取 sizeMask这个是计算key存放位置所在下标用的也就是sizeMask = newTable.length-1 重新修改 扩容阙值条件 threshold = (int)(newCapacity * loadFactor); 判断 HashEntry[] 的任何位置，判断是否存在链表，如果链表只有一个元素，就直接计算 e.hash &amp; sizeMask 在新数组的位置，迁移过去； 如果链表存在多个值，进行第一次遍历链表：拿到链表的最后一个 HashEntry,将其迁移到新数组中； 接着 第二个循环,遍历链表的前面几个 上一个 循环已经拿了 最后一个，根据计算的新数组下标，从新数组中的这个位置拿HashEntry，然后重新构造自己 HashEntry，如果，这个位置不存在HashEntry 的话，那自己就是第一个节点，否则，自己作为头节点加入到 链表中，将原来的HashEntry 作为自己的next。 这种情况有可能会加入到新的链表中，并且作为头节点，也有可能自己占据一个位置。 源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 /** * 扩容处理 * @param node */ private void rehash(HashEntry&lt;K,V&gt; node) { // 旧数组 HashEntry&lt;K,V&gt;[] oldTable = table; int oldCapacity = oldTable.length; // 新数组容量，为旧的2倍 int newCapacity = oldCapacity &lt;&lt; 1; // 下一次的扩容阙值条件 threshold = (int)(newCapacity * loadFactor); // 新数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1;// 遍历 老Segment[]数组,进行数据迁移 for (int i = 0; i &lt; oldCapacity ; i++) { // 链表的第一个 头节点 HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) { HashEntry&lt;K,V&gt; next = e.next; // 重新计算 当前key,在新数组的位置； int idx = e.hash &amp; sizeMask; // 当前 HashEntry对象，没有存在 hash冲突，没有形成链表，直接给值到新的数组中 if (next == null) // Single node on list newTable[idx] = e; else { // Reuse consecutive sequence at same slot /** * * 遍历链表 * * 读取链表的最后一个 HashEntry 并且计算在新数组的中位置，将其放到新数组中 */ HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) { int k = last.hash &amp; sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } newTable[lastIdx] = lastRun; // Clone remaining nodes // 遍历链表的前面几个 上一个 循环已经拿了 最后一个； for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) { V v = p.value; int h = p.hash; int k = h &amp; sizeMask; // 根据计算的新数组下标，从新数组中的这个位置拿HashEntry， // 然后重新构造自己 HashEntry，如果，这个位置不存在HashEntry 的话， // 那自己就是第一个节点，否则，自己作为头节点加入到 链表中，将原来的HashEntry 作为自己的next. // 这种情况有可能会加入到新的链表中，并且作为头节点； // 也有可能自己占据一个位置。 HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); } } } } // 添加新的节点 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; // 更换新的 HashEntry[] 因为已经扩容了 table = newTable } 7、Get(Object key) get 方法并没有加锁，而是通过UNSAFE类的方法来保证线程安全的。 8、总结 ConcurrentHashMap 与 HashTable 都是属于线程安全的 Map,但两者的区别不同。HashTable 的线程安全是基于Sycnchronized,是每个方法都上了sycnchronized；锁住了整个HashTable,效率低下。ConcurrentHashMap 而是采用分段锁的设计，将数据拆分开来存储，也就是 每一个 Segment 都是一个 一个锁，Segment 继承了 ReentrantLock，经过两次 对key的Hash 运算，进行对key在 Segment[] 数组中的位置和Segment[]中的HashEntry[]数组中的位置定位，这样一来，就将数据打散开了存储，在Get的时候，如果不存Hash冲突，也就是不在同一个Segment 就不会出现竞争关系，大大提升了效率问题，也解决了线程安全问题。 ConcurrentHashMap迭代器是弱一致性的。 ConcurrentHashMap有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。","link":"/posts/62ed19e0/"},{"title":"在安卓里没有Spring?不存在的，咱们自己手写实现 IOC 与 DI，在安卓里也不再自己new像","text":"最近接触的项目，与原生的安卓开发相关。 对于安卓的开发并不熟悉，第一次接触到了安卓开发。因为自己用习惯了Spring 框架的开发。用起安卓来，很是不习惯了。 这样子不符合我的个性习惯了，我就是在安卓中使用Spring的类似功能，我就要实现Spring 的 Bean的注入开发，实现 IOC 实现DI。 如何实现请看操作：？ 1、建立一个Android demo 项目结构如下： annotation 包： Autowired 注解与Spring的Autowired功能类似，实现属性注入。 BeanScan 注解 包扫描注解 Componet 注解 与Spring Componet 注解一样。 Table 注解是做 数据的实体与数据库做映射的 一个注解，类似MyBtias-plus的一样 db:是数据库相关的封装 与此文没有多大关系 spring包：就是此文的重点包。 ApplicationContextAware：与Spring 的ApplicationContextAware一样，拿到上下文的对象，拿到对象就可以对获取Bean… BeanFactoryPostProcessor：为spring在容器初始化时对外对外暴露的扩展接口，在Bean实例化前可以对 BeanDeinition的一些属性进行操作修改。 factory包：Bean工厂包，定义了Bean注册的接口，和获取Bean 的接口。 scan包：对项目的跟路径进行扫描，凡事加了注解@Componet注解的，都一将Bean放到IOC容器中。 ApplicationContext：入口类。 项目结构简单完成。 注解： Autowired： 12345678910111213/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-03-29 0w:22 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@Documentedpublic @interface Autowired {} Component 12345678910111213141516171819/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-03-28 01:12 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documentedpublic @interface Component { /** * BeanName * @return */ String name() default &quot;&quot;;} BeanScan 1234567891011@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documentedpublic @interface BeanScan { /** * 包路径 * @return */ String packages();} 2、入口类 ApplicationContext 模仿Spring的refresh()方法。 构造函数： 需要一个 Activity对象，安卓中最重要的就是Activity了，Android四大组件之一。每一个页面都又一个Activity,安卓中有一个主MainActivity，它就是入口，项目启动的时候，就会首先加载主MainActivity。Spring 的包扫描，也就定在这。 12345public ApplicationContext(MainActivity activity) { this.context = activity.getApplicationContext(); handlerBeanScaner(activity);} MainActivity： 123456789101112131415161718@BeanScan(packages = &quot;com.example.testdemo&quot;)public class MainActivity extends Activity { public static Context context; public static ApplicationContext applicationContext; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); context = getApplicationContext(); applicationContext = new ApplicationContext(this); Tiger tiger = applicationContext.getBean(&quot;tiger&quot;); tiger.eat(); }} 每一个Activity都要继承于一个基类Actity。 项目启动的时候会加载一个 onCreate 方法。然后我们就可以开启我们的 安卓Spring之路。 我们构造一个 new ApplicationContext(this)；传入当前对象，目的是拿到当前对象的注解，@BeanScan(packages = “com.example.testdemo”) 12345678910111213141516public ApplicationContext(MainActivity activity) { this.context = activity.getApplicationContext(); handlerBeanScaner(activity);}private void handlerBeanScaner(MainActivity activity) { this.activity = activity; Class&lt;? extends MainActivity&gt; aClass = activity.getClass(); BeanScan annotation = aClass.getAnnotation(BeanScan.class); if (StringUtils.isNotNull(annotation)) { this.packages = annotation.packages(); this.refresh(); }} 拿到了注解的上的要扫描的包路径，然后进行筛选扫描： refresh方法 是不是雨Spirng的有点相似啊。 12345678910111213141516private void refresh() { this.beanFactory = createBeanFactory(); this.scanner = new ClassBeanScanner(beanFactory); this.scanner.scan(this.context, this.packages); invokeBeanFactoryPostProcessors(beanFactory); finishBeanInit(); setApplicationContext(); invokeInitializingBean(beanFactory);} DefaultBeanFactory 实现了 SingletonBeanFactory DefaultBeanFactory 就存放了实例化后的Bean 与 实例话前的 BeanDeinition对象，可以理解为IOC容器。 初始化好后，接下来就是进行扫描。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.example.testdemo.spring.scan;import android.content.Context;import com.example.testdemo.annotation.Component;import com.example.testdemo.spring.bean.BeanDefinition;import com.example.testdemo.spring.bean.GenericBeanDefinition;import com.example.testdemo.spring.factory.DefaultBeanFactory;import com.example.testdemo.utils.StringUtils;import java.io.IOException;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import dalvik.system.DexFile;/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-03-29 01:01 */public abstract class ClassPathBeanDefinitionScanner implements BeanScanner { private DefaultBeanFactory beanFactory; public ClassPathBeanDefinitionScanner(DefaultBeanFactory beanFactory) { this.beanFactory = beanFactory; } /** * 实现了我们的扫描接口的方法 * @param context * @param packages * @return */ @Override public List&lt;BeanDefinition&gt; scan(Context context, String packages) { List&lt;String&gt; className = getClassName(context, packages); List&lt;BeanDefinition&gt; beanDefinitions = new ArrayList&lt;&gt;(); for (String clazz : className) { try { Class&lt;?&gt; aClass = Class.forName(clazz); Component component = aClass.getAnnotation(Component.class); if (StringUtils.isNull(component)) { continue; } GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); String name = component.name(); if (StringUtils.isBlank(name)) { name = toLowerCaseFirstOne(aClass.getSimpleName()); } beanDefinition.setBeanName(name); beanDefinition.setAliasName(name); beanDefinition.setBeanClass(aClass); beanDefinitions.add(beanDefinition); beanFactory.registerSingleton(name, beanDefinition); } catch (ClassNotFoundException e) { e.printStackTrace(); } } return beanDefinitions; } /** * 筛选处指定包下的类 * @param context * @param packageName * @return */ private List&lt;String&gt; getClassName(Context context, String packageName) { List&lt;String&gt; classNameList = new ArrayList&lt;String&gt;(); try { //通过DexFile查找当前的APK中可执行文件 DexFile df = new DexFile(context.getPackageCodePath()); //获取df中的元素 这里包含了所有可执行的类名 该类名包含了包名+类名的方式 Enumeration&lt;String&gt; enumeration = df.entries(); while (enumeration.hasMoreElements()) { String className = enumeration.nextElement(); //在当前所有可执行的类里面查找包含有该包名的所有类 if (className.contains(packageName)) { classNameList.add(className); } } } catch (IOException e) { e.printStackTrace(); } return classNameList; } /** * 首字母小写 * @param s * @return */ private static String toLowerCaseFirstOne(String s) { if (Character.isLowerCase(s.charAt(0))) { return s; } else { return (new StringBuilder()).append(Character.toLowerCase(s.charAt(0))).append(s.substring(1)).toString(); } }} invokeBeanFactoryPostProcessors(beanFactory); 在完成Bean的扫描 将Bean的元数据解析后，进行调用。 123456private void invokeBeanFactoryPostProcessors(DefaultBeanFactory beanFactory) { List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessor = beanFactory.getBeanFactoryPostProcessor(); for (BeanFactoryPostProcessor processor : beanFactoryPostProcessor) { processor.postProcessBeanFactory(this.singletonBeanFactory); }} finishBeanInit(); Bean的实例化，和依赖注入： 12345678910111213private void finishBeanInit() { Map&lt;String, BeanDefinition&gt; beanDefinitionMap = beanFactory.getBeanDefinitionMap(); for (Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) { String beanName = entry.getKey(); GenericBeanDefinition beanDefinition = (GenericBeanDefinition) entry.getValue(); Class&lt;?&gt; beanClass = beanDefinition.getBeanClass(); Object newInstance = createBean(beanClass); registerBean(beanName, newInstance); } // 处理依赖注入 isInjection(beanDefinitionMap);} 依赖注入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void isInjection(Map&lt;String, BeanDefinition&gt; beanDefinitionMap) { // 再次遍历所有的实例化的 BeanDefinition,处理依赖关系 for (Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) { String beanName = entry.getKey(); GenericBeanDefinition beanDefinition = (GenericBeanDefinition) entry.getValue(); Class&lt;?&gt; beanClass = beanDefinition.getBeanClass(); Field[] declaredFields = beanClass.getDeclaredFields(); for (Field field : declaredFields) { Autowired annotation = field.getAnnotation(Autowired.class); if (StringUtils.isNull(annotation)) { continue; } // 当前的实例 Object bean = getBean(beanName); if (StringUtils.isNull(bean)) { throw new BeansException(&quot;Autowired 注入必须不为空 &quot; + field.getName()); } // 允许操作修改 field.setAccessible(true); Class&lt;?&gt; fieldType = field.getType(); // 检查加加了 Autowired 注解的属性，是否加了 Component注解 // 否则抛出异常，找不到实例注入 Component component = fieldType.getAnnotation(Component.class); if (StringUtils.isNotNull(component)) { String fieldBeanName = component.name(); if (StringUtils.isBlank(fieldBeanName)) { // 如果加了，从IOC容器中获取当前属性的实例 fieldBeanName = toLowerCaseFirstOne(fieldType.getSimpleName()); Object fieldObject = getBean(fieldBeanName); if (StringUtils.isNotNull(fieldObject)) { try { // 做属性赋值 field.set(bean, fieldObject); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } } }} spring 在处理注入的时候使用了递归注入，在实例化Bean 的时候，就会检查当前类的有没有属性 加了，Autowired 注解的，如果加了，判断当前属性是否已经实例化了，如果没有，就会实例化下去。实例化的时候，又会检查它的属性是否又依赖注入，有过有又判断当前的属性是否实例化下去，这样子会循环判断下去，所以Spring使用了递归。 相互依赖冲突的化就会出现 这会就有可能会抛出 circle 异常。 在这里我就没有使用递归，分开了两部操作，第一步就是先实例化所有的Bean再处理依赖注入的问题； 这个时候已经完成了DI的操作了。 测试结果： Tiger 类 1234567891011121314@Componentpublic class Tiger implements Person { @Autowired private Women women; @Override public void eat() { women.eat(); System.out.println(&quot;Tiger eat...&quot;); }} Women 类 1234567@Componentpublic class Women implements Person { @Override public void eat() { System.out.println(&quot;women eat...&quot;); }} MyBeanFactoryPostProcessor Bean实例化前的扩展接口 1234567891011121314151617/** * &lt;p&gt; * * &lt;/p&gt; * * @author 永健 * @since 2020-03-29 03:12 */@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor{ @Override public void postProcessBeanFactory(SingletonBeanFactory beanFactory) throws BeansException { Set&lt;String&gt; names = beanFactory.getBeanDefinitionNames(); System.out.println(&quot;共有Bean:&quot;+beanFactory.getBeanDefinitionCount()); }} MyApplicationContextAware 上下文对象 12345678910111213141516171819202122/** * &lt;p&gt; * 拿到上下文对象 可以做一个Bean工厂 * &lt;/p&gt; * * @author 永健 * @since 2020-03-29 03:39 */@Componentpublic class MyApplicationContextAware implements ApplicationContextAware { public static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { context=applicationContext; System.out.println(&quot;拿到Spring上上下文对象&quot;); System.out.println(context); } public static ApplicationContext getApplicationContext() { return context; }} MainActivty 的 onCreate 方法，入口 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); context = getApplicationContext(); applicationContext = new ApplicationContext(this); Tiger tiger = applicationContext.getBean(&quot;tiger&quot;); tiger.eat();} 执行查看打印结果： 打完手工 ​ ::: hljs-center MyBatis – Invalid bound statement (not found) 的所以然来，知其然知其所以然！ 并发工具CountDownLatch是如何实现阻塞的？ 接口不能被实例化，Mybatis的Mapper/Dao为什么却可以@Autowired注入？ :::","link":"/posts/f10cb61a/"},{"title":"mybatis源码分析-启动原理","text":"MMyBatis启动做了些什么？-Mybatis(SpringBoot) 源码分析&emsp; 最近学习了 Mybatis源码，做了些笔记，做一次分享。 &emsp; Mybatis是一套很成熟的orm框架，再次不做过多的介绍，本文基于SpringBoot 去分研究的源码。 &emsp; 加入我们不知道Mybatis 有哪些核心组建，哪些核心类？那么我们就先研究源码，再进行总结！ &emsp; 正式开始，我们带几个疑问？ 1.Mybatis启动的时候做了些什么？2.Mybatis 启动后，发起一个查询命令又做了什么？我们带着这两个疑问进行断点研究源码去，然后再对这两个问题细化分析！ 我们先初始话我们的SpringBoot 工程 1.依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &emsp; 现在我们已经搭好了 SpringBoot工程，接下来我们就是找到入口。 ⚠️ 超级MyBatis 源码地址:https://github.com/memoryoverflow/super-mybatis 我们知道SpringBoot 一般是不写xml文件的，那它的入口在哪？ 当然Mybatis中有个注解 @MapperScan() 注解，这个注解就是我的入口。 SpringBoot启动类中加上 @MapperScan 123456789@SpringBootApplication@MapperScan(&quot;com.mybatis.lyj.sys.mapper&quot;)@SuperMapperScan(basePackages = &quot;com.mybatis.lyj.sys.mapper&quot;)@EnableAutoForwardGeneration(entityPackages = &quot;com.mybatis.lyj.sys.entity&quot;)public class MybatisApplication{ public static void main(String[] args) { SpringApplication.run(MybatisApplication.class, args); }} &emsp;我们虽然找到了 它的启动累注解，但是它的谁来处理它呢？我们command+鼠标点击进入这个 MapperScan.java@MapperScan 源码中看到 123456789101112131415@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented// 此处重点关注这个@Import注解@Import(MapperScannerRegistrar.class)@Import(MapperScannerRegistrar.class)@Repeatable(MapperScans.class)public @interface MapperScan{ ...... // 这个就是我们的常用到的Mapper.class所在包路径 String[] basePackages() default {}; ......} @Import 注解的作用就是网Spring中倒入一个Bean 它倒入的这个MapperScannerRegistrar.class有什么用呢？ 跟它的启动有什么关系呢？当然有关系啊，@MapperScan 故名思议 肯定是扫描 mapper类的作用啊？如果只是倒入一个Bean MapperScannerRegistrar.class 这个类有什么天机呢？ 我们进入看看。 看！ 他继承了 ImportBeanDefinitionRegistrar 接口。看过Spring的知道，spring官方就是用这种方式，实现了@Component、@Service等注解的动态注入机制。 Mybatis 也是这个样子的。我们看这个类中的方法 MapperScannerRegistrar.java1234567891011@Overridepublic void(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry){ // 通过实现这个类 拿到启动类上的MapperScan注解 AnnotationAttributes mapperScanAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) { // 然后new 一个Spring中的扫描对象 ClassPathBeanDefinitionScanner 做扫描 registerBeanDefinitions(mapperScanAttrs, registry); }} registerBeanDefinitions()12345678910111213141516171819202122232425262728293031323334353637383940void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry){ // 此类继承 Spring的 ClassPathBeanDefinitionScanner ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader); Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;); if (!Annotation.class.equals(annotationClass)) { scanner.setAnnotationClass(annotationClass); } Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;); if (!Class.class.equals(markerInterface)) { scanner.setMarkerInterface(markerInterface); } Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;); if (!BeanNameGenerator.class.equals(generatorClass)) { scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); } Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) { scanner.setMapperFactoryBeanClass(mapperFactoryBeanClass); } scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;)); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;)); //注解上的 value值 List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList())); basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText).collect(Collectors.toList())); basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName).collect(Collectors.toList())); // 重写Spring的扫描规则，如果不重写 将Spring的扫描规则来扫描Bean // 将扫描不到 mapper类 scanner.registerFilters(); // 此处重点 扫描mapper 类 scanner.doScan(StringUtils.toStringArray(basePackages));} doScan(String… basePackages)1234567891011121314151617@Overridepublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages){ // 此处还是调用Spring中的扫描器去扫描，只不过实现自己的扫描规则 // 扫描过程 就不看了 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) { LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in \\'&quot; + Arrays.toString(basePackages) + &quot;\\' package. Please check your configuration.&quot;); } else { // 对扫描结果进行修改？？为什么要进行修改呢？ processBeanDefinitions(beanDefinitions); } return beanDefinitions;} processBeanDefinitions(Set beanDefinitions)对扫描 mapper接口的结果进行修改？？为什么要进行修改呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions){ GenericBeanDefinition definition; // 多所以的 BeanDefinition 的BeanClass进行修改 为MapperFactoryBean.class for (BeanDefinitionHolder holder : beanDefinitions) { definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; &quot;Creating MapperFactoryBean with name \\'&quot; + holder.getBeanName() + &quot;\\' and \\'&quot; + beanClassName + &quot;\\' mapperInterface&quot;); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 definition.setBeanClass(this.mapperFactoryBeanClass); definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) { definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; } else if (this.sqlSessionFactory != null) { definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory); explicitFactoryUsed = true; } if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) { if (explicitFactoryUsed) { LOGGER.warn(() -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); } definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; } else if (this.sqlSessionTemplate != null) { if (explicitFactoryUsed) { LOGGER.warn(() -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); } definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate); explicitFactoryUsed = true; } if (!explicitFactoryUsed) { LOGGER.debug(() -&gt; &quot;Enabling autowire by type for MapperFactoryBean with name \\'&quot; + holder.getBeanName() + &quot;\\'.&quot;); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); } }} 原因：为什么要修改呢？首先，mapper是一个接口，不能实例话。那怎么办？ 放到Spring管理的话 它并没有直接对接口的处理生成代理对象！！但是呢 它提供了一个FactoryBean 接口；大家都知道 Spring中又两种Bean一种就是普通Bean 一种就是 FactoryBean； mybatis中就是利用这个FactoryBean 放到 BeanDefinition 中，在Spring中实例话所以非懒加载的单利bean时候，如果 是 FactoryBean 的话 就会获取getObject方法来获取这个实例。 在这个方法中mybatis 返回的是一个mapper代理对象。此处就完成了 对 Mapper接口的扫描，接下来的实例话 就交给Spring来处理了。这个就是 @MapperScan 的作用了。 这个时候是不是就有一个结果了啊1、MyBatis启动的时候利用Spring的扫描器去扫描Mapper类，将扫描结果进行替换，BeanClass进行替换为 MapperFacotoryBean.class ，完成mapper代理对象的初始化。 Mybatis启动就做了这点东西吗？ 不还有xml的解析，自动化配置处理…. xml解析我们接下来看 xml的解析，先看看SpringBoot Mybatis-starer jar包下有那几个包 我们来看这个自动化配置的Stater这个自动化配置的包做什么呢？我们都知道，mybatis启动 需要配置一下配置信息吧，数据源什么的，因为要初始话，所以就要去读取配置文件的配置信息吧。 我们来看看它干了什么？&gt; 先看 MybatisProperties.class 这里面只有它的属性 MybatisProperties.class123456789101112131415161718192021222324252627282930313233343536373839404142public static final String MYBATIS_PREFIX = &quot;mybatis&quot;;private static final ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();/** * Location of MyBatis xml config file. * mybatis的配置文件 */private String configLocation;/** * Locations of MyBatis mapper files. * mapper 文件路径 */private String[] mapperLocations;/** * * Packages to search type aliases. (Package delimiters are &quot;,; \\\\t\\&quot;) */// 别名包 private String typeAliasesPackage;///** * The super class for filtering type alias. * If this not specifies, the MyBatis deal as type alias all classes that searched from typeAliasesPackage. */private Class&lt;?&gt; typeAliasesSuperType;/** * Packages to search for type handlers. (Package delimiters are &quot;,; \\\\t\\&quot;) */private String typeHandlersPackage;/** * Indicates whether perform presence check of the MyBatis xml config file. */private boolean checkConfigLocation = false;/** * Execution mode for {@link org.mybatis.spring.SqlSessionTemplate}. */private ExecutorType executorType;/** * Externalized properties for MyBatis configuration. */private Properties configurationProperties;/** * A Configuration object for customize default settings. If {@link #configLocation} * is specified, this property is not used. */// 重点在这个 Configuration 这个 Configuration 贯彻全文的，画圈圈 要考试的@NestedConfigurationPropertyprivate Configuration configuration; resolveMapperLocations()扫描xml将其转换为 Resource[] MybatisAutoConfiguration.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152@org.springframework.context.annotation.Configuration@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})// 数据元处理@ConditionalOnSingleCandidate(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)// 数据源自动化配置@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration implements InitializingBean{ private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class); private final MybatisProperties properties; private final Interceptor[] interceptors; private final ResourceLoader resourceLoader; private final DatabaseIdProvider databaseIdProvider; private final List&lt;ConfigurationCustomizer&gt; configurationCustomizers; public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) { this.properties = properties; this.interceptors = interceptorsProvider.getIfAvailable(); this.resourceLoader = resourceLoader; this.databaseIdProvider = databaseIdProvider.getIfAvailable(); this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable(); } @Override public void afterPropertiesSet() { checkConfigFileExists(); } private void checkConfigFileExists() { if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) { Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation()); Assert.state(resource.exists(), &quot;Cannot find config location: &quot; + resource + &quot; (please add config file or check your Mybatis configuration)&quot;); } } // 关键点 在这里 初始化工长，并且完成xml解析 @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) { factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); } applyConfiguration(factory); if (this.properties.getConfigurationProperties() != null) { factory.setConfigurationProperties(this.properties.getConfigurationProperties()); } if (!ObjectUtils.isEmpty(this.interceptors)) { factory.setPlugins(this.interceptors); } if (this.databaseIdProvider != null) { factory.setDatabaseIdProvider(this.databaseIdProvider); } if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) { factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); } if (this.properties.getTypeAliasesSuperType() != null) { factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType()); } if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) { factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); } // mapper 扫描。将mapper.xml转换为Resource if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) { factory.setMapperLocations(this.properties.resolveMapperLocations()); } // 工厂初始化 return factory.getObject(); } private void applyConfiguration(SqlSessionFactoryBean factory) { Configuration configuration = this.properties.getConfiguration(); if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) { configuration = new Configuration(); } if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) { for (ConfigurationCustomizer customizer : this.configurationCustomizers) { customizer.customize(configuration); } } factory.setConfiguration(configuration); } @Bean @ConditionalOnMissingBean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) { ExecutorType executorType = this.properties.getExecutorType(); if (executorType != null) { return new SqlSessionTemplate(sqlSessionFactory, executorType); } else { return new SqlSessionTemplate(sqlSessionFactory); } } // 处理 @Mapper注解的 public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware { private BeanFactory beanFactory; private ResourceLoader resourceLoader; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { if (!AutoConfigurationPackages.has(this.beanFactory)) { logger.debug(&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;); return; } logger.debug(&quot;Searching for mappers annotated with @Mapper&quot;); List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory); if (logger.isDebugEnabled()) { packages.forEach(pkg -&gt; logger.debug(&quot;Using auto-configuration base package \\'{}\\'&quot;, pkg)); } ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); if (this.resourceLoader != null) { scanner.setResourceLoader(this.resourceLoader); } scanner.setAnnotationClass(Mapper.class); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(packages)); } @Override public void setBeanFactory(BeanFactory beanFactory) { this.beanFactory = beanFactory; } @Override public void setResourceLoader(ResourceLoader resourceLoader) { this.resourceLoader = resourceLoader; } }} 现在跟中下去 工厂的初始化SqlSessionFactoryBean.class &gt; getObject() -&gt;afterPropertiesSet()-&gt;buildSqlSessionFactory() SqlSessionFactoryBean 实现了 InitializingBean 接口 所以在SPring实例化bean的时候会执行afterPropertiesSet；主要看 buildSqlSessionFactory（） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131protected SqlSessionFactory buildSqlSessionFactory() throws Exception { final Configuration targetConfiguration; XMLConfigBuilder xmlConfigBuilder = null; if (this.configuration != null) { targetConfiguration = this.configuration; if (targetConfiguration.getVariables() == null) { targetConfiguration.setVariables(this.configurationProperties); } else if (this.configurationProperties != null) { targetConfiguration.getVariables().putAll(this.configurationProperties); } } else if (this.configLocation != null) { xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties); targetConfiguration = xmlConfigBuilder.getConfiguration(); } else { LOGGER.debug(() -&gt; &quot;Property \\'configuration\\' or \\'configLocation\\' not specified, using default MyBatis Configuration&quot;); targetConfiguration = new Configuration(); Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables); } Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory); Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory); Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl); if (hasLength(this.typeAliasesPackage)) { scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias); } if (!isEmpty(this.typeAliases)) { Stream.of(this.typeAliases).forEach(typeAlias -&gt; { targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias); LOGGER.debug(() -&gt; &quot;Registered type alias: \\'&quot; + typeAlias + &quot;\\'&quot;); }); } if (!isEmpty(this.plugins)) { Stream.of(this.plugins).forEach(plugin -&gt; { targetConfiguration.addInterceptor(plugin); LOGGER.debug(() -&gt; &quot;Registered plugin: \\'&quot; + plugin + &quot;\\'&quot;); }); } if (hasLength(this.typeHandlersPackage)) { scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers())).filter(clazz -&gt; ClassUtils.getConstructorIfAvailable(clazz) != null).forEach(targetConfiguration.getTypeHandlerRegistry()::register); } if (!isEmpty(this.typeHandlers)) { Stream.of(this.typeHandlers).forEach(typeHandler -&gt; { targetConfiguration.getTypeHandlerRegistry().register(typeHandler); LOGGER.debug(() -&gt; &quot;Registered type handler: \\'&quot; + typeHandler + &quot;\\'&quot;); }); } if (this.databaseIdProvider != null) { //fix #64 set databaseId before parse mapper xmls try { targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource)); } catch (SQLException e) { throw new NestedIOException(&quot;Failed getting a databaseId&quot;, e); } } Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache); if (xmlConfigBuilder != null) { try { xmlConfigBuilder.parse(); LOGGER.debug(() -&gt; &quot;Parsed configuration file: \\'&quot; + this.configLocation + &quot;\\'&quot;); } catch (Exception ex) { throw new NestedIOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex); } finally { ErrorContext.instance().reset(); } } targetConfiguration.setEnvironment(new Environment(this.environment, this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory, this.dataSource)); if (this.mapperLocations != null) { if (this.mapperLocations.length == 0) { LOGGER.warn(() -&gt; &quot;Property \\'mapperLocations\\' was specified but matching resources are not found.&quot;); } else { for (Resource mapperLocation : this.mapperLocations) { if (mapperLocation == null) { continue; } try { // mapper.xml文件的解析，即 xml的节点解析 insert update select delete // 以及结果集映射等相关数据，做好数据数据的对应的初始化，然后增删改，就会 // 在回来，去找到对应的方法数据 这是一个一来一回的过程，启动的时候就是相当于铺路。 XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(), targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments()); xmlMapperBuilder.parse(); } catch (Exception e) { throw new NestedIOException(&quot;Failed to parse mapping resource: \\'&quot; + mapperLocation + &quot;\\'&quot;, e); } finally { ErrorContext.instance().reset(); } LOGGER.debug(() -&gt; &quot;Parsed mapper file: \\'&quot; + mapperLocation + &quot;\\'&quot;); } } } else { LOGGER.debug(() -&gt; &quot;Property \\'mapperLocations\\' was not specified.&quot;); } //targetConfiguration 整个mybatis的操作过程都围绕着它转，所以在解析xml的时候，就已经对它的属性进行填充了 return this.sqlSessionFactoryBuilder.build(targetConfiguration); } build(Configuration config)12345//build() 方法 就new一个工厂public SqlSessionFactory build(Configuration config){ return new DefaultSqlSessionFactory(config);} xml解析 parse()12345678910111213141516public void parse(){ if (!configuration.isResourceLoaded(resource)) { // 解析Mapper xml文件 configurationEleme(parser.evalNode(&quot;/mapper&quot;)); // 填充mapper.xml的 resource configuration.addLoadedResource(resource); //绑定命名空间 bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements();} parse().configurationElement(XNode context)//解析Mapper xml文件 1234567891011121314151617181920212223private void configurationElement(XNode context){ try { String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper\\'s namespace cannot be empty&quot;); } builderAssistant.setCurrentNamespace(namespace); cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); cacheElement(context.evalNode(&quot;cache&quot;)); parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 处理 节点为select insert update delete buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is \\'&quot; + resource + &quot;\\'. Cause: &quot; + e, e); }} parse().configurationElement(XNode context)1234567891011121314151617181920212223private void configurationElement(XNode context){ try { String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper\\'s namespace cannot be empty&quot;); } builderAssistant.setCurrentNamespace(namespace); cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); cacheElement(context.evalNode(&quot;cache&quot;)); parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 处理 节点为select insert update delete buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is \\'&quot; + resource + &quot;\\'. Cause: &quot; + e, e); }} pare().buildStatementFromContext1234567891011121314151617181920212223242526private void buildStatementFromContext(List&lt;XNode&gt; list){ if (configuration.getDatabaseId() != null) { buildStatementFromContext(list, configuration.getDatabaseId()); } buildStatementFromContext(list, null);}private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId){ for (XNode context : list) { // XMLStatementBuilder sql解析对象 注意 带着configuration的 final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try { // 解析 statementParser.parseStatementNode(); } catch (IncompleteElementException e) { configuration.addIncompleteStatement(statementParser); } }} pare().buildStatementFromContext(List list, String requiredDatabaseId)1234567891011121314151617private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId){ for (XNode context : list) { // XMLStatementBuilder sql解析对象 注意 带着configuration的 final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try { // 解析 statementParser.parseStatementNode(); } catch (IncompleteElementException e) { configuration.addIncompleteStatement(statementParser); } }} 解析sql 节点 标签 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void parseStatementNode(){ // sql语句的唯一id String id = context.getStringAttribute(&quot;id&quot;); String databaseId = context.getStringAttribute(&quot;databaseId&quot;); if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) { return; } // 语句类型 String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; // 是否使用了缓存 boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect); boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect); boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false); // Include Fragments before parsing XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); String parameterType = context.getStringAttribute(&quot;parameterType&quot;); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); String lang = context.getStringAttribute(&quot;lang&quot;); LanguageDriver langDriver = getLanguageDriver(lang); // Parse selectKey after includes and remove them. processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) { keyGenerator = configuration.getKeyGenerator(keyStatementId); } else { keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;, configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE; } // 处理sql标签的其它属性 SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString())); Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;); Integer timeout = context.getIntAttribute(&quot;timeout&quot;); String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;); String resultType = context.getStringAttribute(&quot;resultType&quot;); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); String resultMap = context.getStringAttribute(&quot;resultMap&quot;); String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;); String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;); String resultSets = context.getStringAttribute(&quot;resultSets&quot;); // 将解析出来的sql标签的属性，也就是当前条sql语句相关的所有信息 添加到 MappedStatement中去 看看下面的图片 它的属性是不是上面 解析出来的属性呢 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);} 将sql节点标签解析完成后，将信息存储到 configuratin的MappedStatementMap中，key 就是命名空间+sql+idbuilderAssistant.addMappedStatement(……)addMappedStatement()方法的部分代码 123456789101112131415.... MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType).resource(resource).fetchSize(fetchSize).timeout(timeout).statementType(statementType).keyGenerator(keyGenerator).keyProperty(keyProperty).keyColumn(keyColumn).databaseId(databaseId).lang(lang).resultOrdered(resultOrdered).resultSets(resultSets).resultMaps(getStatementResultMaps(resultMap, resultType, id)).resultSetType(resultSetType).flushCacheRequired(valueOrDefault(flushCache, !isSelect)).useCache(valueOrDefault(useCache, isSelect)).cache(currentCache); ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id); if(statementParameterMap !=null) { statementBuilder.parameterMap(statementParameterMap); } MappedStatement statement = statementBuilder.build(); // 将MappedStatement 存到configuration 的MappedStatement map中 configuration.addMappedStatement(statement);.... bindMapperForNamespace()MappedStatement id：就是当亲啊sql的 mapper.xml命名空间+sql节点的Id这个id将会作为key ，MappedStatement ：作为value放大configration中的一个 map中；在查询的时候就会根据 这个id拿到这个sql对应的MappedStatement，进行后续操作 &gt; 看看绑定命名 空间的方法 bindMapperForNamespace() 123456789101112131415161718192021222324252627282930private void bindMapperForNamespace(){ String namespace = builderAssistant.getCurrentNamespace(); if (namespace != null) { Class&lt;?&gt; boundType = null; try { // 命名空间的Class =mapper接口对象 boundType = Resources.classForName(namespace); } catch (ClassNotFoundException e) { //ignore, bound type is not required } if (boundType != null) { if (!configuration.hasMapper(boundType)) { // Spring may not know the real resource name so we set a flag // to prevent loading again this resource from the mapper interface // look at MapperAnnotationBuilder#loadXmlResource configuration.addLoadedResource(&quot;namespace:&quot; + namespace); // 将mapper对象class放到 configuration 的一个MapperRegistry 对象中 而MapperRegistry 又一个Map属性就是放 mapper接口的代理工厂的MapperProxyFactory对象的，代理对象的产生就是在这里的 newInstance（）方法。 前面提到过的FactoryBean 的getObject方法中拿的Bean就是经过 configuration到这里出来的哦。 configuration.addMapper(boundType); } } }} configuration.addMapper(boundType); mapperRegistry.addMapper(boundType) knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type)); 到现在 已经简单的看到了 基于SpringBoot的Mybatis启动的过程，知道它初始化了哪些重要的东西了","link":"/posts/8497ffc5/"}],"tags":[{"name":"加密文章","slug":"加密文章","link":"/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"http协议","slug":"http协议","link":"/tags/http%E5%8D%8F%E8%AE%AE/"},{"name":"锁","slug":"锁","link":"/tags/%E9%94%81/"},{"name":"lock","slug":"lock","link":"/tags/lock/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"gitlab-ci","slug":"gitlab-ci","link":"/tags/gitlab-ci/"},{"name":"gitlab-runner","slug":"gitlab-runner","link":"/tags/gitlab-runner/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"存储过程","slug":"存储过程","link":"/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"私有云盘","slug":"私有云盘","link":"/tags/%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98/"},{"name":"nextcloud","slug":"nextcloud","link":"/tags/nextcloud/"},{"name":"SpringBoot starter","slug":"SpringBoot-starter","link":"/tags/SpringBoot-starter/"},{"name":"Nexus","slug":"Nexus","link":"/tags/Nexus/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"集合","slug":"集合","link":"/tags/%E9%9B%86%E5%90%88/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","link":"/tags/ConcurrentHashMap/"},{"name":"IOC Spring","slug":"IOC-Spring","link":"/tags/IOC-Spring/"},{"name":"源码学习","slug":"源码学习","link":"/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"private","slug":"private","link":"/categories/private/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"锁","slug":"锁","link":"/categories/%E9%94%81/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"mybatis","slug":"java/mybatis","link":"/categories/java/mybatis/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"java","slug":"锁/java","link":"/categories/%E9%94%81/java/"},{"name":"mybatis","slug":"mybatis","link":"/categories/mybatis/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"docker","slug":"java/docker","link":"/categories/java/docker/"},{"name":"Nexus","slug":"Nexus","link":"/categories/Nexus/"},{"name":"持续自动化部署","slug":"vue/持续自动化部署","link":"/categories/vue/%E6%8C%81%E7%BB%AD%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"linux","slug":"java/linux","link":"/categories/java/linux/"},{"name":"mybatis","slug":"数据库/mybatis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"},{"name":"并发编程","slug":"锁/java/并发编程","link":"/categories/%E9%94%81/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"存储过程","slug":"数据库/mybatis/存储过程","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"并发编程","slug":"java/并发编程","link":"/categories/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]}